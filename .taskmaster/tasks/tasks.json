{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Monorepo scaffolding and tooling",
        "description": "Create ghc-platform monorepo structure with backend, frontend, infra. Add editor/formatting/linting and basic Makefile for common dev tasks.",
        "details": "Create directories: /ghc-platform/{backend,frontend,infra}. Add .editorconfig, .gitignore, README. Add Makefile targets: run-backend, run-worker, run-frontend, db-migrate, db-revise, temporal-up, temporal-down. Pseudo-code: mkdir -p backend/app/{db,schemas,auth,llm,temporal/{workflows,activities},routers}; mkdir -p frontend/src; mkdir -p infra. Initialize git.\nTools: pre-commit with hooks for black, isort, ruff, mypy (backend) and eslint/prettier (frontend).",
        "testStrategy": "Manual verification: repo structure exists; pre-commit hooks trigger on commit; Makefile targets show help and run without error stubs.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:17:39.213Z"
      },
      {
        "id": 2,
        "title": "Dev infra: Docker Compose for Postgres + Temporal + PgAdmin",
        "description": "Provision local infrastructure services required by backend and worker.",
        "details": "Create infra/docker-compose.yml with services:\n- postgres: image postgres:16, POSTGRES_USER/PASSWORD/DB via .env, ports 5432:5432, healthcheck.\n- temporal: image temporalio/auto-setup:latest, ports 7233:7233.\n- temporal-ui: image temporalio/ui:latest, env TEMPORAL_ADDRESS=temporal:7233, ports 8233:8233.\n- pgadmin or adminer optional.\nInclude named volumes for data. Add .env.example for DB creds.\nPseudo-code YAML snippet:\nservices:\n  postgres:\n    image: postgres:16\n    environment: {POSTGRES_USER: app, POSTGRES_PASSWORD: app, POSTGRES_DB: app}\n    ports: [\"5432:5432\"]\n  temporal:\n    image: temporalio/auto-setup:latest\n    ports: [\"7233:7233\"]\n  temporal-ui:\n    image: temporalio/ui:latest\n    environment: {TEMPORAL_ADDRESS: temporal:7233}\n    ports: [\"8233:8080\"]",
        "testStrategy": "Run docker compose up -d; verify ports: 5432, 7233, 8233 reachable. Temporal UI opens; healthchecks healthy. Backend not required yet.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:18:06.830Z"
      },
      {
        "id": 3,
        "title": "Backend bootstrap (FastAPI + dependencies)",
        "description": "Initialize Python project with FastAPI, SQLAlchemy 2.x, Alembic, Pydantic v2, Temporal SDK, auth libs.",
        "details": "Create backend/pyproject.toml with dependencies: fastapi, uvicorn[standard], sqlalchemy>=2, alembic, psycopg2-binary, pydantic>=2, python-jose[cryptography], httpx, temporalio, tenacity, structlog, python-dotenv, orjson, typing-extensions. Dev deps: pytest, pytest-asyncio, httpx[http2], ruff, black, mypy, types-requests.\nScaffold backend/app/main.py with FastAPI app factory.\nPseudo-code:\napp = FastAPI()\n@app.get(\"/health\")\nasync def health(): return {\"ok\": True}",
        "testStrategy": "pip install via poetry/pip, run uvicorn app.main:app --reload, curl /health returns ok. Ruff/mypy pass on initial files.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:18:36.826Z"
      },
      {
        "id": 4,
        "title": "Configuration settings and environment management",
        "description": "Implement app/config.py Settings with env vars for DB, Clerk, Temporal, OpenAI; load from .env.",
        "details": "Create app/config.py using Pydantic BaseSettings (v2). Fields: DATABASE_URL, CLERK_JWT_ISSUER, CLERK_JWKS_URL, CLERK_AUDIENCE, TEMPORAL_NAMESPACE=default, TEMPORAL_TASK_QUEUE=growth-agency, OPENAI_API_KEY.\nAdd .env.example with placeholders; ensure settings = Settings().\nUsage: from app.config import settings in modules.",
        "testStrategy": "Unit test loads Settings from test .env; missing required env raises error; values accessible across modules.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:19:08.315Z"
      },
      {
        "id": 5,
        "title": "Alembic setup and initial migrations for full schema",
        "description": "Initialize Alembic and implement migrations for enums and all tables defined in PRD.",
        "details": "Initialize Alembic: alembic init alembic; configure sqlalchemy.url to settings.DATABASE_URL via env in alembic.ini or env.py. Create migration version to:\n- CREATE EXTENSION pgcrypto;\n- Create enums: user_role, client_status, campaign_status, artifact_type, workflow_kind, workflow_status, asset_status, asset_source_type.\n- Tables: orgs, users, clients, product_offers, product_offer_price_points, campaigns, artifacts (with GIN index on data), experiments, assets (GIN on content), asset_performance_snapshots, company_swipe_brands, company_swipe_assets (indexes), company_swipe_media, client_swipe_assets, workflow_runs, activity_logs with indexes from PRD.\nUse alembic.op.execute for CREATE TYPE and indexes; or SQLAlchemy enums bound to existing enum types.\nPseudo-code:\nop.execute(\"CREATE TYPE user_role AS ENUM ('partner',...)\")\nop.create_table('orgs', ...)\nop.create_index('idx_artifacts_gin_data', 'artifacts', [sa.text('data')], postgresql_using='gin')",
        "testStrategy": "Run alembic upgrade head against local Postgres; inspect schema; run simple INSERTs to validate enums; verify indexes exist with psql \\d+.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:21:20.051Z"
      },
      {
        "id": 6,
        "title": "SQLAlchemy 2.x ORM models and enums",
        "description": "Create ORM models mirroring all tables and map PostgreSQL enums.",
        "details": "Implement app/db/base.py with engine and SessionLocal; DeclarativeBase subclass. Create app/db/enums.py with Enum classes using sqlalchemy.Enum(mapped). Create models: Org, User, Client, ProductOffer, ProductOfferPricePoint, Campaign, Artifact, Experiment, Asset, AssetPerformanceSnapshot, CompanySwipeBrand, CompanySwipeAsset, CompanySwipeMedia, ClientSwipeAsset, WorkflowRun, ActivityLog. Include relationships where useful (e.g., swipe -> brand, media -> swipe). Ensure UUID columns use sqlalchemy.dialects.postgresql.UUID(as_uuid=True) with default=uuid4. Timestamps timezone-aware.\nPseudo-code class:\nclass Client(Base):\n  __tablename__='clients'\n  id = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)\n  org_id = mapped_column(ForeignKey('orgs.id', ondelete='CASCADE'), nullable=False)\n  name = mapped_column(String, nullable=False)\n  status = mapped_column(Enum(ClientStatusEnum), default=ClientStatusEnum.active, nullable=False)",
        "testStrategy": "Mypy type-check models; create a short script session.add/commit and query; ensure enum round-trips; foreign keys cascade.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:23:17.789Z"
      },
      {
        "id": 7,
        "title": "Repository layer (CRUD) for core entities",
        "description": "Implement repository functions for clients, campaigns, artifacts, experiments, assets, swipes, workflows.",
        "details": "Create app/db/repositories/*.py with typed functions: create/read/update/list/delete. All queries filtered by org_id for multi-tenancy. Repos include pagination and simple search. Artifacts repo must support get_latest_by_type(client_id, type) and insert_* helpers for each artifact_type. Workflow repo writes workflow_runs and activity_logs.\nPseudo-code:\nclass ClientsRepo:\n  def list(self, org_id, limit=50, offset=0):\n    return session.execute(select(Client).where(Client.org_id==org_id).limit(limit).offset(offset)).scalars().all()\n  def create(self, org_id, data): ...",
        "testStrategy": "Unit tests with a transactional test DB (pytest fixture). Verify create/list/update; artifact latest returns correct version; multi-tenant isolation enforced.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:25:00.850Z"
      },
      {
        "id": 8,
        "title": "Pydantic v2 schemas for artifacts (definition files)",
        "description": "Define strongly-typed Pydantic models for all artifact JSON shapes.",
        "details": "Create app/schemas/*.py: client_canon.py, metric_schema.py, strategy_sheet.py, experiment_spec.py, asset_brief.py, qa_report.py, experiment_report.py, playbook.py. Use Pydantic v2 BaseModel; include sensible defaults; ensure model_dump by_alias=False. Keep field names camelCase as in PRD to match frontend types; store as JSONB in artifacts.data.\nPseudo-code:\nclass ClientCanon(BaseModel):\n  clientId: str\n  brand: CanonBrand\n  offers: list[CanonOffer]\n  icps: list[CanonICP]\n  voiceOfCustomer: CanonVoiceOfCustomer\n  constraints: CanonConstraints\n  contentPatterns: CanonContentPatterns",
        "testStrategy": "Schema tests: construct models from exemplar JSON; validate defaults; round-trip model_dump JSON is serializable; align with TS types later.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:26:36.057Z"
      },
      {
        "id": 9,
        "title": "Schemas for swipe assets and API DTOs",
        "description": "Define Pydantic models for CompanySwipeBrand, CompanySwipeMedia, CompanySwipeAsset, ClientSwipeAsset and common DTOs.",
        "details": "Create app/schemas/swipe_assets.py mirroring DB fields; include Optional fields for nullable columns and nested media/brand for enriched responses. Add simple API DTOs (ClientCreate, CampaignCreate, etc.) in schemas/common.py to validate request payloads.\nPseudo-code:\nclass ClientSwipeAsset(BaseModel):\n  id: str\n  org_id: str\n  client_id: str\n  company_swipe_id: str | None = None\n  tags: list[str] = []\n  is_good_example: bool = False\n  is_bad_example: bool = False",
        "testStrategy": "Unit tests building models; ensure extra is forbidden or allowed as needed; serialize to JSON; use with repos in tests.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:27:02.865Z"
      },
      {
        "id": 10,
        "title": "Clerk JWT verification middleware and auth dependency",
        "description": "Implement manual JWT verification using Clerk JWKS with caching and FastAPI dependency returning AuthContext.",
        "details": "Create app/auth/clerk.py: fetch JWKS with httpx, cache via lru_cache and refresh on kid miss; verify with python-jose using issuer and audience from settings. Create app/auth/dependencies.py: HTTPBearer to extract token; verify_clerk_token; build AuthContext(user_id, org_id from custom claim if available). Optionally upsert Clerk user to users table on first request.\nPseudo-code:\nclaims = verify_clerk_token(token)\nif 'sub' not in claims: raise 401\nreturn AuthContext(user_id=claims['sub'], org_id=claims.get('org_id'))",
        "testStrategy": "Mock JWKS in tests; validate: good token passes; wrong aud/iss fails; missing bearer returns 401. Integration test with sample Clerk token if available.",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:27:44.026Z"
      },
      {
        "id": 11,
        "title": "FastAPI application assembly and router skeleton",
        "description": "Wire FastAPI app with CORS, JSON response class, exception handlers, dependency injection, and register routers.",
        "details": "In app/main.py: create_app() sets up CORS (frontend origin), ORJSONResponse, lifespan to init DB, include routers placeholders: clients, campaigns, artifacts, assets, swipes, experiments, workflows. Add /health endpoint. Configure logging with structlog.\nPseudo-code:\napp = FastAPI(default_response_class=ORJSONResponse)\napp.include_router(clients.router)\n...",
        "testStrategy": "Run uvicorn and GET /health; OpenAPI docs show all router tags; middleware order correct; CORS allows frontend origin.",
        "priority": "high",
        "dependencies": [
          "7",
          "8",
          "9",
          "10"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:28:46.421Z"
      },
      {
        "id": 12,
        "title": "Temporal client helper and Worker process",
        "description": "Create shared Temporal client helper and a worker entrypoint that registers all workflows and activities.",
        "details": "app/temporal/client.py: async get_temporal_client() connects to localhost:7233 with namespace.\napp/temporal/worker.py: Worker(client, task_queue=settings.TEMPORAL_TASK_QUEUE, workflows=[...], activities=[...]). Use ThreadPoolExecutor for sync activities hitting DB/HTTP. Add CLI entry point python -m app.temporal.worker.\nPseudo-code:\nclient = await Client.connect(\"localhost:7233\", namespace=settings.TEMPORAL_NAMESPACE)\nworker = Worker(client, task_queue=settings.TEMPORAL_TASK_QUEUE, workflows=[...], activities=[...])\nawait worker.run()",
        "testStrategy": "Run worker while Temporal is up; verify it connects and registers; no import errors with placeholder workflows/activities.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:29:25.833Z"
      },
      {
        "id": 13,
        "title": "Workflow tracking repositories and status updater",
        "description": "Implement repositories for workflow_runs and activity_logs and helper to create/update workflow run records from API and activities.",
        "details": "Repos: create_workflow_run(org_id, client_id, campaign_id, workflow_id, run_id, kind) and update_workflow_status(run_id, status, finished_at). activity_logs: append(step, status, payload_in/out, error). Helper functions for activities to call log_activity(workflow_run_id,...). Optionally add a background task that reconciles run status from Temporal when API queries status.\nPseudo-code:\nclass WorkflowsRepo:\n def create_run(...): session.add(WorkflowRun(...))\n def set_status(id, status): ...\n def log_activity(...): session.add(ActivityLog(...))",
        "testStrategy": "Unit tests writing and querying logs; simulate status changes; ensure cascade delete works; indexes used.",
        "priority": "high",
        "dependencies": [
          "5",
          "7",
          "12"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:29:33.389Z"
      },
      {
        "id": 14,
        "title": "Temporal workflow: ClientOnboardingWorkflow",
        "description": "Implement ClientOnboardingWorkflow with signals approve_canon and approve_metric_schema and activity calls.",
        "details": "Create app/temporal/workflows/client_onboarding.py as in PRD. Use workflow.unsafe.imports_passed_through() to import activities. Run: build_client_canon_activity -> wait approval -> build_metric_schema_activity -> wait approval -> persist_client_onboarding_artifacts_activity. Ensure types are JSON-serializable. Use workflow.wait_condition and schedule_to_close_timeout.\nPseudo-code (workflow.run):\nself.canon = await execute_activity(build_client_canon_activity, {...})\nawait wait_condition(lambda: self._canon_approved)\nself.metric = await execute_activity(build_metric_schema_activity, {...})\nawait wait_condition(lambda: self._metric_approved)\nawait execute_activity(persist_client_onboarding_artifacts_activity, {...})",
        "testStrategy": "Temporal unit tests using workflow testing environment (temporalio.testing). Simulate signals; assert activities invoked; verify determinism (no non-deterministic code in workflow).",
        "priority": "high",
        "dependencies": [
          "12",
          "8",
          "13"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:30:14.184Z"
      },
      {
        "id": 15,
        "title": "Activities: client_onboarding_activities (LLM + DB)",
        "description": "Add activities to generate ClientCanon and MetricSchema, and persist artifacts to DB.",
        "details": "Create app/temporal/activities/client_onboarding_activities.py with @activity.defn functions: build_client_canon_activity(params), build_metric_schema_activity(params), persist_client_onboarding_artifacts_activity(params). Use repos to read onboarding intake (stub) and insert artifacts with type 'client_canon' and 'metric_schema'. Use LLM agents in app/llm/* modules (stubs initially) returning Pydantic models; store model_dump JSON in artifacts.data.\nPseudo-code:\npayload = onboarding_repo.get(...)\ncanon = run_client_brain(payload)\nartifacts_repo.insert(org_id, client_id, type='client_canon', data=canon.model_dump())\nreturn canon.model_dump()",
        "testStrategy": "Activity unit tests with in-memory or transactional DB; mock LLM to return deterministic models; assert artifacts rows created and JSON schema matches Pydantic.",
        "priority": "high",
        "dependencies": [
          "7",
          "8",
          "14"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:30:20.726Z"
      },
      {
        "id": 16,
        "title": "Routers: Artifacts API (list, latest-by-type)",
        "description": "Expose REST endpoints to query artifacts by client, campaign, type, and fetch latest per type.",
        "details": "Create routers/artifacts.py with endpoints:\n- GET /artifacts?clientId=&type=&latest=true|false (filters: org_id from auth, pagination)\n- GET /artifacts/{id}\n- POST /artifacts (admin only; primarily created by activities)\nQuery JSONB with SQLAlchemy; return data as-is. Add simple ETag or updated_at for caching later.",
        "testStrategy": "API tests with auth context; seed artifacts via repo; verify listing, latest selection (max version/created_at), 404 on missing, multi-tenant isolation.",
        "priority": "high",
        "dependencies": [
          "11",
          "7",
          "8",
          "13",
          "14",
          "15"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:32:01.379Z"
      },
      {
        "id": 17,
        "title": "Routers: Clients API + onboarding starter",
        "description": "CRUD endpoints for clients and POST to start onboarding workflow, persisting raw onboarding payload.",
        "details": "routers/clients.py endpoints: GET /clients, POST /clients, GET /clients/{id}, PATCH, DELETE. POST /clients/{id}/onboarding to save onboarding payload (simple table or JSON file) and start ClientOnboardingWorkflow via get_temporal_client(). Create workflow_run record with kind=client_onboarding. Return workflow_run_id. All endpoints enforce org_id scoping.\nPseudo-code:\nhandle = await temporal.start_workflow(ClientOnboardingWorkflow.run, ClientOnboardingInput(...), id=f\"client-onboarding-{org}-{client}\", task_queue=settings.TEMPORAL_TASK_QUEUE)\nworkflows_repo.create_run(..., handle.id, handle.first_execution_run_id, kind='client_onboarding')",
        "testStrategy": "API tests: create client, start onboarding; assert workflow run row created; verify 403 when accessing other orgâ€™s client; validate payload persisted.",
        "priority": "high",
        "dependencies": [
          "11",
          "7",
          "13",
          "14",
          "15"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:32:27.404Z"
      },
      {
        "id": 18,
        "title": "Temporal workflow: CampaignPlanningWorkflow",
        "description": "Implement Strategy planning workflow with approval signal and activity to build strategy sheet.",
        "details": "Create app/temporal/workflows/campaign_planning.py with signal approve_strategy_sheet and run() that calls build_strategy_sheet_activity and waits for approval. Ensure timeouts and inputs per PRD.",
        "testStrategy": "Workflow unit test: mock activities; signal approval; assert completion without nondeterminism.",
        "priority": "high",
        "dependencies": [
          "12",
          "8",
          "13"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:33:06.576Z"
      },
      {
        "id": 19,
        "title": "Activities: strategy_activities (build StrategySheet)",
        "description": "Create LLM-backed activity to generate StrategySheet and save as artifact.",
        "details": "app/temporal/activities/strategy_activities.py with @activity.defn build_strategy_sheet_activity(params) that loads ClientCanon/MetricSchema artifacts, business goal, calls campaign_architect LLM, inserts StrategySheet artifact.\nPseudo-code:\ncanon = artifacts_repo.get_latest(client_id, 'client_canon')\nmetric = artifacts_repo.get_latest(client_id, 'metric_schema')\nstrategy = run_campaign_architect(canon, metric, goal)\nartifacts_repo.insert(..., type='strategy_sheet', data=strategy)",
        "testStrategy": "Unit test: mock repos to return canon/metric; mock LLM; assert strategy artifact inserted; JSON schema validated by Pydantic model.",
        "priority": "medium",
        "dependencies": [
          "7",
          "8",
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:33:13.972Z"
      },
      {
        "id": 20,
        "title": "Routers: Campaigns API (+ plan workflow)",
        "description": "CRUD for campaigns and endpoint to start CampaignPlanningWorkflow.",
        "details": "routers/campaigns.py endpoints: GET/POST/PATCH/DELETE campaigns scoped by org and client. POST /campaigns/{id}/plan to start CampaignPlanningWorkflow with business_goal_id, creating workflow_run record (kind=campaign_planning).",
        "testStrategy": "API tests: create campaign then start plan; verify workflow run record; ensure org scoping; invalid campaign returns 404/403 appropriately.",
        "priority": "high",
        "dependencies": [
          "11",
          "7",
          "13",
          "18",
          "19"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:33:34.351Z"
      },
      {
        "id": 21,
        "title": "Temporal workflows: ExperimentDesign, CreativeProduction, ExperimentCycle, PlaybookUpdate, TestCampaign",
        "description": "Add remaining workflow classes and register in worker; wire signals for approvals and stop; follow PRD skeletons.",
        "details": "Create workflow classes in app/temporal/workflows/experiment_design.py, creative_production.py, experiment_cycle.py, playbook_update.py, test_campaign.py. Implement per PRD:\n- ExperimentDesignWorkflow: generate specs, approve_experiments signal.\n- CreativeProductionWorkflow: create briefs, generate assets, run QA, approve_assets signal.\n- ExperimentCycleWorkflow: ensure configs, periodic polling, build reports, stop signal.\n- PlaybookUpdateWorkflow: run_now signal, update from reports.\n- TestCampaignWorkflow: E2E smoke from canon to QA.\nRegister all in worker.",
        "testStrategy": "Workflow tests: stub activities; simulate signals; time skipping with workflow.sleep; ensure determinism and completion paths.",
        "priority": "high",
        "dependencies": [
          "12",
          "8",
          "13",
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:35:53.161Z"
      },
      {
        "id": 22,
        "title": "Activities: experiments, assets, QA, signals, playbook",
        "description": "Implement activity modules that LLM-generate specs/assets, run QA checks, integrate with ad platforms stubs, and persist outputs.",
        "details": "Create modules:\n- experiment_activities.py: build_experiment_specs_activity, create_asset_briefs_for_experiments_activity.\n- asset_activities.py: generate_assets_for_brief_activity, persist_assets_activity.\n- qa_activities.py: run_brand_qa_activity, run_compliance_qa_activity.\n- signal_activities.py: ensure_experiment_configured_activity, fetch_experiment_results_activity, build_experiment_report_activity.\n- playbook_activities.py: update_playbook_from_reports_activity.\nEach loads prerequisites (artifacts, experiments), calls LLMs in app/llm/*, persists artifacts/assets/asset_performance_snapshots.\nPseudo-code example persist_assets_activity:\nfor a in assets:\n  asset_id = assets_repo.create(..., content=a)\n  qa_repo.insert_reports(asset_id, brand_qa, compliance_qa)",
        "testStrategy": "Unit tests per activity: mock LLM and repos; assert DB writes; validate Pydantic schemas; ensure idempotency where required (e.g., upsert briefs by artifact key).",
        "priority": "medium",
        "dependencies": [
          "7",
          "8",
          "21"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:35:59.859Z"
      },
      {
        "id": 23,
        "title": "Routers: Workflows signals + Experiments/Assets/Swipes APIs",
        "description": "Expose endpoints to signal workflows and manage experiments, assets, and swipes (company/client).",
        "details": "Create routers/workflows.py: POST signals for approve-canon, approve-metric-schema, approve-strategy, approve-experiments, approve-assets, stop-experiment-cycle. Validate ownership via workflow_runs lookup.\nCreate routers/experiments.py: list/create/update experiments for a campaign.\nCreate routers/assets.py: list assets by campaign/experiment; get asset content; update status (approve/reject).\nCreate routers/swipes.py: company swipes search/list/detail; client swipes CRUD/link, tag, mark good/bad; optional import endpoint to upsert external ads.\nPseudo-code signal:\nrun = workflows_repo.get(workflow_run_id)\nhandle = temporal.get_workflow_handle(run.temporal_workflow_id)\nawait handle.signal('approve_assets', approved_ids, rejected_ids)",
        "testStrategy": "API tests: signal endpoints update workflow state (verified via mocked Temporal client); swipes search filters by brand/platform; client swipes create/link flows; permissions enforced.",
        "priority": "high",
        "dependencies": [
          "11",
          "7",
          "9",
          "13",
          "14",
          "18",
          "21",
          "22"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:36:30.329Z"
      },
      {
        "id": 24,
        "title": "Frontend setup: Vite + React + TS + Tailwind + ShadCN UI + Clerk",
        "description": "Initialize frontend app, configure Tailwind and shadcn/ui, and integrate Clerk provider and protected routes.",
        "details": "Steps:\n- npm create vite@latest frontend -- --template react-ts (or in existing folder).\n- Install tailwindcss postcss autoprefixer; init tailwind config; add index.css with @tailwind directives.\n- npx shadcn-ui init; configure components.json; generate base components (button, input, textarea, dialog, table, badge, sheet, tabs, card).\n- npm i @clerk/clerk-react react-router-dom @tanstack/react-query.\n- Wrap app in <ClerkProvider>; add ProtectedRoute component using SignedIn/SignedOut.\n- Setup basic layout with ShadCN components.",
        "testStrategy": "Run npm run dev; UI loads; Clerk sign-in screen appears when SignedOut; basic ShadCN components render correctly.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:38:33.415Z"
      },
      {
        "id": 25,
        "title": "Frontend API client, types, and core pages (Clients, Campaigns, Swipes, Onboarding/Approvals)",
        "description": "Create API client with Clerk token injection, TS types mirroring Pydantic, and ShadCN-based pages for core flows incl. Temporal approvals.",
        "details": "Implement src/api/client.ts useApiClient() to inject Authorization: Bearer token. Create modules clients.ts, campaigns.ts, artifacts.ts, swipes.ts, workflows.ts.\nTypes: src/types/{artifacts.ts,swipes.ts,common.ts} mirroring backend schemas.\nPages:\n- ClientsList + ClientSetupWizard: collect onboarding payload, POST /clients/{id}/onboarding, poll artifacts latest, open Dialog to approve Canon/MetricSchema via workflow signals.\n- Campaigns: NewCampaign, Overview, Plan Strategy with approve dialog (approve-strategy signal).\n- Experiments & Assets: show ExperimentSpecs and AssetBrief/Assets; approve/reject assets (approve-assets signal). Creative Inbox list filtered by status with QA scores.\n- Swipes: CompanySwipesPage (search, preview media), ClientSwipesPage (link/tag good/bad, attach to canon patterns).\nUse ShadCN Table, Dialog, Tabs, Card, Badge, Button.\nPseudo-code approve canon:\nconst data = await request(`/workflows/${runId}/signals/approve-canon`, {method:'POST', body: JSON.stringify({approved:true, updatedCanon})});",
        "testStrategy": "E2E happy-path with local backend/worker: create client, start onboarding, approve canon/metric via dialogs, start campaign planning, approve strategy, list swipes and link to client. Use Cypress or Playwright smoke tests; verify API calls succeed and UI states update.",
        "priority": "high",
        "dependencies": [
          "24",
          "16",
          "20",
          "23"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-11T20:40:14.057Z"
      },
      {
        "id": 26,
        "title": "Local Postgres with Docker Compose, apply Alembic migrations, and verify backend connectivity",
        "description": "Provision a local Postgres instance via Docker Compose, run Alembic migrations to create the schema, and add a backend health check to verify DB connectivity.",
        "details": "Implementation steps:\n\n1) Docker Compose for Postgres\n- Create docker-compose.yml at repo root (or infra/docker/docker-compose.yml):\n  version: \"3.9\"\n  services:\n    db:\n      image: postgres:16\n      container_name: app-postgres\n      environment:\n        POSTGRES_USER: postgres\n        POSTGRES_PASSWORD: postgres\n        POSTGRES_DB: app\n      ports:\n        - \"5432:5432\"  # change to 5433:5432 if you already run Postgres locally\n      volumes:\n        - pgdata:/var/lib/postgresql/data\n      healthcheck:\n        test: [\"CMD-SHELL\", \"pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB -h 127.0.0.1 || exit 1\"]\n        interval: 5s\n        timeout: 5s\n        retries: 20\n        start_period: 5s\n  volumes:\n    pgdata:\n- If port 5432 is taken, change mapping to 5433:5432 and adjust DATABASE_URL accordingly.\n\n2) Environment configuration\n- Add .env (or .env.local) at backend/ root used by settings and Alembic (Task 5 configured Alembic to read settings.DATABASE_URL):\n  DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/app\n- If you changed the host port to 5433: DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5433/app\n- Ensure python-dotenv is loaded by settings so both FastAPI and Alembic pick up the same URL (per Task 3/5 conventions).\n\n3) Helper scripts (optional but recommended)\n- Add Makefile targets at repo root:\n  db-up:  docker compose up -d db\n  db-down: docker compose down -v\n  db-logs: docker compose logs -f db\n  db-psql: docker compose exec -e PGPASSWORD=postgres db psql -U postgres -d app\n  migrate-up: ALEMBIC_CONFIG=alembic.ini alembic upgrade head\n  migrate-down: ALEMBIC_CONFIG=alembic.ini alembic downgrade -1\n- Ensure these run from the directory containing alembic.ini (Task 5).\n\n4) Apply Alembic migrations\n- Start DB: docker compose up -d db and wait for healthy status.\n- Run: alembic upgrade head (from backend where alembic.ini/env.py is configured per Task 5).\n- Expect creation of pgcrypto extension, enums, and all PRD tables and indexes.\n\n5) Backend DB connectivity verification\n- Add a DB health endpoint to FastAPI to validate runtime connectivity.\n  Example (sync SQLAlchemy):\n    from fastapi import APIRouter, HTTPException\n    from sqlalchemy import text\n    from app.db import engine  # or however Task 3 exposes the Engine\n    router = APIRouter()\n    @router.get(\"/health/db\")\n    def db_health():\n        try:\n            with engine.connect() as conn:\n                conn.execute(text(\"SELECT 1\"))\n            return {\"db\": \"ok\"}\n        except Exception as e:\n            raise HTTPException(status_code=503, detail=f\"db error: {e}\")\n  If using async engine/session, adapt to async with and await session.execute(text(\"SELECT 1\")).\n- Optionally add a startup check that logs a clear error if DB is unreachable.\n\n6) Troubleshooting\n- Permission for CREATE EXTENSION: ensure migrations are executed as the superuser (default POSTGRES_USER in image is superuser).\n- If Alembic cannot find DATABASE_URL, verify env loading in alembic/env.py and backend settings.\n- To reset DB: docker compose down -v && docker compose up -d db and re-run migrations.\n",
        "testStrategy": "Manual verification steps:\n1) Start database\n- Run: docker compose up -d db\n- Confirm health: docker compose ps (Status should be healthy) or docker compose logs -f db until pg_isready reports accepting connections.\n\n2) Run migrations\n- From the directory with alembic.ini: alembic upgrade head\n- Expect INFO logs for each revision; no errors.\n\n3) Inspect schema via psql\n- docker compose exec -e PGPASSWORD=postgres db psql -U postgres -d app -c \"\\dx\"  -> pgcrypto listed\n- docker compose exec ... -c \"\\dt\"  -> PRD tables present (e.g., orgs, users, clients, campaigns, artifacts, assets, experiments, etc.)\n- docker compose exec ... -c \"\\d+ artifacts\"  -> GIN index on data present\n- docker compose exec ... -c \"SELECT enum_range(NULL::user_role);\" -> returns enum values\n\n4) Backend connectivity\n- Start API: uvicorn app.main:app --reload\n- GET /health -> returns ok (from Task 3)\n- GET /health/db -> returns {\"db\":\"ok\"}; if fails, logs show error and endpoint returns 503\n\n5) Smoke DB write/read\n- Using psql, insert a trivial row into a small table (e.g., orgs or a lookup table) if safe, or run SELECT 1 only.\n- Alternatively, write a short script using SQLAlchemy engine from backend to execute SELECT 1 and exit 0.\n\n6) Idempotency check\n- Run alembic upgrade head again; expect no changes and no errors.\n",
        "status": "done",
        "dependencies": [
          "5",
          "3"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-11T21:21:59.326Z"
      },
      {
        "id": 27,
        "title": "Run backend and Temporal worker locally, verify health, and smoke-test workflow registration",
        "description": "Spin up the backend and Temporal worker against a local Temporal server, verify /health responds, and start a minimal workflow to confirm the worker is polling and registered.",
        "details": "Goal: Ensure the local developer stack can run FastAPI and the Temporal worker, the health endpoint responds, and the worker is correctly registered and able to accept workflow tasks.\n\nPrereqs and environment:\n- Ensure Python deps are installed for the backend (per Task 3) and Temporal worker (per Task 12).\n- Create/update .env (or environment) with at least:\n  - TEMPORAL_ADDRESS=localhost:7233\n  - TEMPORAL_NAMESPACE=default\n  - TEMPORAL_TASK_QUEUE=app-task-queue (must match settings used in app.temporal.worker)\n  - Optional if Task 26 is complete and health checks DB connectivity: DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/app\n- Ensure PYTHONPATH includes backend/ (or run from the backend project root so module imports resolve).\n\n1) Start a local Temporal server (choose one):\n- Option A: Temporal Dev Server (recommended)\n  - temporal server start-dev --ui-port 8233 --db-filename temporal.db --namespace default\n  - Visit http://localhost:8233 to confirm the Temporal Web UI is up.\n- Option B: Temporalite\n  - temporalite start --namespace default --ip 0.0.0.0 --port 7233\n\n2) Run the backend API:\n- From backend/ (where app/main.py lives):\n  - uvicorn app.main:app --reload --port 8000\n- Expected logs: Uvicorn running on http://127.0.0.1:8000.\n\n3) Verify health endpoint:\n- curl -s http://localhost:8000/health\n- Expected: HTTP 200 and a JSON body. If only Task 3 is in place: {\"ok\": true}. If Task 26 (DB connectivity) has been merged, ensure Postgres is up; response should include DB status or succeed without errors.\n\n4) Run the Temporal worker:\n- In a new terminal, from backend/:\n  - python -m app.temporal.worker\n- Expected logs: connection to localhost:7233, namespace=default, and a started worker with the configured task queue; no import errors for registered workflows/activities.\n\n5) Confirm worker registration (no workflow start yet):\n- temporal task-queue describe --task-queue \"$TEMPORAL_TASK_QUEUE\" --namespace \"$TEMPORAL_NAMESPACE\"\n- Expected: pollerCount >= 1 (indicates the worker is polling the queue).\n\n6) Smoke-test by starting a lightweight workflow:\n- Prefer a minimal or placeholder workflow registered by the worker (e.g., TestCampaignWorkflow from Task 21). If your workflows require inputs, pass the simplest valid payload according to their signatures.\n- Option A: Python async snippet (save as scripts/start_smoke_workflow.py):\n  \"\"\"\n  import asyncio, os\n  from temporalio.client import Client\n  from app.settings import settings\n  from app.temporal.workflows.test_campaign import TestCampaignWorkflow  # adjust if using a different workflow\n\n  async def main():\n      client = await Client.connect(os.getenv(\"TEMPORAL_ADDRESS\", \"localhost:7233\"), namespace=os.getenv(\"TEMPORAL_NAMESPACE\", \"default\"))\n      run_id = await client.start_workflow(\n          TestCampaignWorkflow.run,  # method reference\n          {\"dry_run\": True},        # adjust to the workflow's expected input\n          id=\"smoke-\" + __import__(\"time\").strftime(\"%Y%m%d%H%M%S\"),\n          task_queue=settings.TEMPORAL_TASK_QUEUE,\n      )\n      print(\"Started workflow run:\", run_id)\n\n  if __name__ == \"__main__\":\n      asyncio.run(main())\n  \"\"\"\n  - Run: python scripts/start_smoke_workflow.py\n- Option B: Temporal CLI (requires knowing the registered workflow type name):\n  - temporal workflow start --type TestCampaignWorkflow --task-queue \"$TEMPORAL_TASK_QUEUE\" --namespace \"$TEMPORAL_NAMESPACE\" --input '{\"dry_run\":true}'\n\n7) Observe execution:\n- In worker logs, verify task polling and workflow execution logs appear.\n- In Temporal Web UI (http://localhost:8233), find the workflow execution; confirm it is Running or Completed depending on the workflow behavior.\n\n8) Cleanup:\n- If the workflow is long-running, terminate it via Web UI or CLI:\n  - temporal workflow terminate --workflow-id <id> --namespace \"$TEMPORAL_NAMESPACE\" --reason \"Smoke test cleanup\"\n- Stop worker (Ctrl+C) and backend (Ctrl+C) when done.\n\nNotes and troubleshooting:\n- If pollerCount is 0: verify TEMPORAL_NAMESPACE and TEMPORAL_TASK_QUEUE match between the worker and your CLI command; ensure worker is running and connected.\n- If the worker fails to start: check for import errors from workflows in app.temporal.workflows.* (Tasks 21/14/18). Ensure the Python path and dependencies are correct.\n- If health fails and Task 26 is merged: start Postgres per Task 26 before hitting /health.\n- If CLI start by workflow type fails due to unknown type name, prefer the Python snippet which imports the workflow symbol directly.\n",
        "testStrategy": "Manual smoke test steps:\n1) Temporal server up:\n   - Run temporal server start-dev (or temporalite). Visit http://localhost:8233; UI loads without errors.\n2) Backend health:\n   - Run uvicorn app.main:app --reload --port 8000.\n   - curl http://localhost:8000/health returns HTTP 200.\n   - If DB health is enabled (Task 26 merged), start Postgres first; /health indicates DB OK.\n3) Worker registration:\n   - Start worker: python -m app.temporal.worker (no import errors in logs).\n   - temporal task-queue describe --task-queue \"$TEMPORAL_TASK_QUEUE\" --namespace \"$TEMPORAL_NAMESPACE\" shows pollerCount >= 1.\n4) Workflow start and visibility:\n   - Start a workflow via Python snippet or CLI.\n   - In the Temporal Web UI, the workflow appears under Executions with status Running or Completed.\n   - Worker logs show tasks handled (workflow started, any activities scheduled/started if applicable).\n5) Cleanup:\n   - If the workflow is still running, terminate it via UI or CLI; confirm it disappears from Open workflows.\n6) Acceptance criteria:\n   - /health returns 200 consistently.\n   - Worker maintains at least one active poller for the configured task queue for 1+ minute.\n   - A workflow can be started successfully and is visible in the Temporal UI; no unexpected exceptions in worker logs.\n",
        "status": "done",
        "dependencies": [
          "3",
          "12",
          "21"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-11T21:22:08.384Z"
      },
      {
        "id": 28,
        "title": "Run frontend against local backend/Temporal with Clerk auth and validate API-backed pages",
        "description": "Launch the full local stack (Temporal, backend, worker, frontend), sign in via Clerk, and verify core React pages render data from authenticated API calls and workflow-driven flows.",
        "details": "Scope: Wire the already-built frontend (Tasks 24, 25) to the running backend and Temporal worker (Task 27), authenticate with Clerk, and validate that protected routes fetch and display data from the API, including onboarding and approvals flows.\n\nPrerequisites (ensure these are set up before starting):\n- Task 27 completed: Temporal server up, backend running on http://localhost:8000, worker connected and workflows registered.\n- Task 10 completed: Backend verifies Clerk JWTs via JWKS and builds AuthContext.\n- Task 24 and 25 completed: Frontend scaffolding with Clerk provider, protected routes, API client with token injection, and core pages.\n- A Postgres/DB available if required by backend (consistent with local dev settings used in Task 27).\n\nEnvironment configuration:\n- Clerk dashboard (dev instance):\n  - Add http://localhost:5173 to allowed origins and redirect URLs for development.\n  - Locate Publishable Key, Issuer, Audience, and JWKS URL (from JWT template or API keys section).\n- Frontend .env.local (in frontend project root):\n  - VITE_CLERK_PUBLISHABLE_KEY=pk_test_...\n  - VITE_API_BASE_URL=http://localhost:8000\n- Backend .env (already set in Task 27 + Task 10; verify values):\n  - CLERK_ISSUER=... (from Clerk)\n  - CLERK_AUDIENCE=... (from Clerk JWT template)\n  - CLERK_JWKS_URL=... (from Clerk)\n  - TEMPORAL_* values as per Task 27\n\nCORS or proxy (choose one):\n- Easiest: enable CORS on FastAPI for http://localhost:5173 (dev only). In app startup, add CORSMiddleware allowing origin http://localhost:5173, methods [*], headers [*], and credentials. Ensure Authorization header is allowed.\n- Alternative: Vite dev server proxy. Configure vite.config.ts to proxy /api to http://localhost:8000 and set frontend base URL to /api. Use only one approach to avoid confusing origins.\n\nRun sequence:\n1) Start Temporal server (temporal server start-dev) and confirm UI on http://localhost:8233.\n2) Start backend (uvicorn app.main:app --reload --port 8000). Confirm GET /health returns 200.\n3) Start worker (python -m app.temporal.worker). Confirm it connects and polls the configured task queue without errors.\n4) Start frontend (npm run dev). Open http://localhost:5173.\n\nAuthentication flow validation:\n- On visiting a protected route, the Clerk sign-in should render. Sign in with a dev user from Clerk.\n- After sign-in, verify:\n  - React Query/Api client attaches Authorization: Bearer <ClerkJWT> to requests (check browser devtools Network tab).\n  - Backend logs show authenticated requests with user/org context (per Task 10), responses are 200.\n\nPage validations (happy path):\n- Clients page: should fetch and list clients (or show empty state if none). Create or import a test client as supported by the UI.\n- Onboarding wizard: submit onboarding payload, POST /clients/{id}/onboarding should start the Temporal onboarding workflow. Dialogs for approvals should appear when artifacts are ready. Use the UI to send approval signals and verify the onboarding status/artifacts update.\n- Campaigns page: create a campaign, start strategy planning; approve strategy sheet via dialog. Confirm status changes and any returned artifact links/data render.\n- Swipes/artifacts pages: verify lists render, rows clickable, and detail views fetch and display data.\n\nError and edge checks:\n- SignedOut state: navigate to a protected route while signed out; verify redirect to sign-in and API requests are not fired (or receive 401 and UI handles gracefully).\n- Token refresh: leave page open for >5 minutes; ensure subsequent queries still succeed (Clerk rotates tokens automatically; the API client should always inject a fresh token from Clerk).\n- CORS/proxy: if requests fail with CORS error, confirm either CORS middleware is active (correct origin) or Vite proxy is configured; do not use both simultaneously.\n- Clock skew: if JWT nbf/exp errors occur, sync local system clock or reduce skew in Clerk dev settings if available.\n\nDocumentation and DX:\n- Add a README section (dev runbook) with exact steps, required env vars, and troubleshooting tips above.\n- Record short Loom/GIF of the flow: sign-in -> create client -> run onboarding -> approve -> see data update.\n",
        "testStrategy": "Manual end-to-end smoke test with clear pass criteria:\n1) Auth gate: Visiting a protected route shows Clerk sign-in when logged out; after login, the protected page renders (PASS if redirect/sign-in occurs and page loads post-login).\n2) Authenticated API calls: On Clients page load, Network tab shows GET requests to backend with Authorization: Bearer <token> and response 200 (PASS if at least one authenticated call succeeds).\n3) Clients CRUD/display: Create or select a client; page reflects server response and displays client info (PASS if UI updates without errors and data persists across refresh).\n4) Onboarding workflow: Start onboarding for a client; UI polls for artifacts; approve canon and metric schema via dialogs; final status shows completed and artifacts render (PASS if both approvals complete and artifacts visible in UI without errors).\n5) Campaign planning: Start planning; approve strategy; status transitions to approved/planned; any artifacts/links display (PASS if workflow step completes and UI reflects state).\n6) Swipes/artifacts lists: List renders rows or an empty state; clicking a row fetches details and renders content (PASS if details view loads with 200 response).\n7) SignedOut behavior: Log out; access a protected route; verify redirect to sign-in and no data is leaked (PASS if no protected data loads and route is gated).\n8) Resilience checks: Wait for token refresh window (>5 min); perform a new action; requests succeed (PASS if no 401 due to expired token). If a CORS error is observed, adjust per instructions and re-run until requests succeed.\nOptional automation: Add a lightweight Playwright script to programmatically log in via Clerk test user, navigate to Clients, assert 200 responses and visible text. Treat this as a smoke test, not full E2E.",
        "status": "pending",
        "dependencies": [
          "24",
          "25",
          "10",
          "27"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Workflow triggers in UI",
        "description": "Add UI controls to create clients/campaigns, start onboarding and campaign planning workflows, and send approval signals from the app.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "28"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-11T21:36:21.954Z"
      },
      {
        "id": 30,
        "title": "Workflow approvals UI",
        "description": "Add UI to view workflow runs and send approval signals (canon, metric, strategy, experiments, assets) with minimal forms.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "29"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-11T21:36:28.155Z"
      },
      {
        "id": 31,
        "title": "CLI smoke tests for API endpoints",
        "description": "Use curl/HTTPie against local backend to exercise health, clients create/list, campaigns create/plan, workflows list/logs, artifacts list, swipes list, signals endpoints (approve canon/metric/strategy/experiments/assets), ensuring Temporal/DB up. Document commands and expected responses.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "28"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Automated tests for API endpoints",
        "description": "Add backend test suite (pytest/httpx) covering health/db, clients create/list/onboarding start, campaigns create/plan, workflows list/logs and signal endpoints, artifacts list, swipes list. Use test client with fixture data and mock Temporal where needed.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "31"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "E2E validation of Client Onboarding workflow with Clerk-auth",
        "description": "Implement a Playwright-based end-to-end test suite that validates the Client Onboarding workflow using Clerk authentication, covering client creation, onboarding start, approvals (canon and metric schema), artifact persistence, workflow completion, and org scoping/authorization.",
        "details": "Scope\n- Full-stack validation from the browser through the API to Temporal, using real Clerk-issued session tokens in the browser and backend JWT verification.\n- Covers: client creation, onboarding payload submission, workflow run creation, approvals via UI, artifacts persisted, and strict org_id scoping.\n\nTech stack and location\n- Tests: Playwright (TypeScript) under e2e/onboarding.spec.ts.\n- Fixtures/utilities: e2e/utils/{clerk.ts, db.ts, temporal.ts}.\n- Seed script: scripts/seed_e2e.py (creates orgs, users, mappings) and scripts/reset_e2e.py (cleanup).\n\nEnvironment and configuration\n- Frontend env: CLERK_PUBLISHABLE_KEY, NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY set; app configured for Clerk.\n- Backend env: CLERK_JWKS_URL or CLERK_ISSUER for JWT verification; OR use Clerk Secret to fetch JWKS at runtime if already implemented. Ensure org_id claim used by backend matches UI org selector.\n- Temporal: docker compose up temporal; worker started via python -m app.temporal.worker.\n- Deterministic LLM outputs: configure app/llm/* to use deterministic/stubbed models for test (env flag e.g., LLM_MODE=stub).\n\nData model and seeding\n- Create two orgs: orgA, orgB (ids like org_aaaa, org_bbbb) and map to backend org records.\n- Users: userA (member of orgA), userB (member of orgB). Optionally add userA to both orgs to test org switching.\n- Ensure DB clean before/after via reset_e2e.py (truncate artifacts, workflows, clients tables).\n\nPlaywright helpers\n- clerk.ts: programmatic sign-in using Clerk testing helpers (or Dev Browser) to create a session for a given org and return an authenticated page context.\n- db.ts: lightweight HTTP utils to the backend (with session token) for assertions when UI canâ€™t expose details easily.\n- temporal.ts: waitForWorkflowRun helper polling GET /workflows/{id} or workflows list endpoint to synchronize with backend state.\n\nTest scenarios\n1) Happy path (orgA)\n- Sign in as userA in orgA; navigate to Clients; create a new client (unique name per run).\n- Open ClientSetupWizard; fill onboarding payload; submit; assert POST /clients/{id}/onboarding succeeds and UI shows a workflow run id.\n- Wait for UI to display Canon ready for approval; open dialog; approve canon; verify UI transitions to metric schema stage.\n- Approve metric schema; wait until UI marks onboarding complete.\n- Assertions:\n  - Artifacts list shows entries for client_canon and metric_schema with non-empty JSON.\n  - Workflow run status is completed and kind=client_onboarding.\n  - No console errors; network log shows 2 approval signal requests with 2xx responses.\n\n2) Authorization and org scoping\n- Still signed in as userA in orgA, capture client id and workflow id.\n- Sign out; sign in as userB in orgB.\n- Attempt to access the client detail URL directly; expect 403/404 and no sensitive data displayed.\n- Attempt to send approval signals for the captured workflow via API client; expect 403.\n\n3) Refresh/resume behavior\n- During waiting-for-approval state (before canon approval), refresh the page; verify state persists and the approve dialog is still actionable after reconnection.\n\n4) Worker/process resilience (optional but included)\n- Start onboarding; stop worker for a short interval; restart worker; verify workflow resumes and approvals still complete successfully.\n\nImplementation notes\n- Use data-testids on UI elements (buttons, dialogs, status chips) to make tests robust.\n- Add polling with reasonable timeouts (e.g., 60â€“120s) for workflow-driven state changes.\n- Ensure tests run serially for onboarding suite to avoid temporal queue contention in CI.\n- Provide npm scripts: \"e2e:up\" (start backend, worker, temporal), \"e2e\" (run playwright headed/headless), \"e2e:ci\" (headless with retries), and \"e2e:down\" (cleanup).\n- CI job: cache Playwright binaries; run seed/reset scripts before suite; export Clerk keys from CI secrets.\n\nAcceptance criteria\n- All scenarios pass locally and in CI twice in a row (flakiness check).\n- Evidence of artifacts persisted and workflow completion captured in screenshots and trace.\n- Unauthorized org access reliably returns 403/404 and does not leak records.\n- Test runtime under 5 minutes on CI with timeouts tuned.\n- Documentation added to README-e2e.md with setup, running, and troubleshooting.",
        "testStrategy": "Setup\n- Ensure Temporal stack is running; start backend API and worker process.\n- Export Clerk publishable and secret keys in env; confirm JWT verification works locally (hit a protected endpoint with a Clerk session, receive 200).\n- Run scripts/reset_e2e.py then scripts/seed_e2e.py to prepare orgs/users.\n\nTests (Playwright)\n1) Happy-path\n- Run e2e/onboarding.spec.ts test:should onboard a client end-to-end.\n- Verify: client appears in list, onboarding POST returns workflow_run_id, canon approval success toast, metric schema approval success toast, onboarding status shows Complete.\n- Call backend artifacts endpoint with the same session: expect at least two artifacts with types client_canon and metric_schema and valid JSON bodies.\n- Fetch workflow run detail: status=completed, kind=client_onboarding.\n\n2) Org scoping\n- With userB session (orgB), request the orgA client detail page: expect 403/404 in UI (assert on HTTP response and UI message).\n- Attempt approval signal to the orgA workflow: expect 403 response and no state change (re-fetch workflow run to confirm unchanged).\n\n3) Refresh/resume\n- Before approving canon, refresh; assert state still shows waiting-for-canon; after approval, assert UI transitions within timeout.\n\n4) Worker restart\n- Pause worker for 10â€“20s after onboarding starts; resume; assert run completes after approvals.\n\nDiagnostics\n- Enable Playwright trace and video; on failure, collect network logs and screenshots.\n- Assert no console errors; assert no 5xx responses during the flow.\n\nExit criteria\n- All assertions pass on two consecutive CI runs; flakes investigated and flake rate <1%.",
        "status": "done",
        "dependencies": [
          "17",
          "14",
          "12",
          "15",
          "23",
          "25",
          "30"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-11T23:03:21.838Z"
      },
      {
        "id": 34,
        "title": "E2E validation of Campaign Planning workflow with Clerk-auth (strategy approval)",
        "description": "Implement a Playwright end-to-end test that validates the Campaign Planning workflow using real Clerk authentication, covering campaign creation, planning start, strategy sheet generation, approval via UI, artifact persistence, status transitions, and strict org scoping/authorization.",
        "details": "Scope and goals\n- Validate the full-stack Campaign Planning flow: authenticated browser -> API -> Temporal workflow -> activities -> repositories -> approval signal -> completion.\n- Cover: campaign creation, POST /campaigns/{id}/plan with business_goal_id, strategy sheet artifact creation by activity, approval (approve-strategy) via the UI, workflow run status transitions, and org scoping/authorization (no cross-org visibility or approvals).\n\nTech stack and file layout\n- Tests: Playwright (TypeScript) under e2e/campaign_planning.spec.ts.\n- Utilities (create if not already available from other E2E tasks):\n  - e2e/utils/clerk.ts: helper to create Clerk test users/sessions and return browser storageState or auth headers.\n  - e2e/utils/db.ts: minimal PG client to query workflow_runs and artifacts tables for assertions.\n  - e2e/utils/temporal.ts: helpers to wait/poll for workflow completion or specific activity logs if needed.\n\nAuthentication\n- Use real Clerk-issued session tokens in the browser. Log in via:\n  - Programmatic session injection: create a Clerk session server-side (using Clerk SDK with secret key), set __session cookie into Playwright context storageState before navigating; or\n  - UI login using Clerk-hosted components if available in the app. Prefer session injection for stability and speed.\n- Create two users in different orgs (orgA_user and orgB_user). Ensure org membership reflects appâ€™s org_id scoping.\n\nData setup\n- Ensure seed data exists for:\n  - An org A and org B.\n  - At least one client in org A (clientA).\n  - At least one business goal in org A (goalA) used by the planning endpoint.\n- If a seeding script exists (e.g., scripts/reset_e2e.py and scripts/seed_e2e.py), call them in test setup; otherwise, create minimal fixtures via API/DB calls.\n\nDeterministic strategy activity\n- To avoid flaky LLM calls from build_strategy_sheet_activity, allow a deterministic mode (e.g., STRATEGY_LLM_PROVIDER=fake or ACTIVITY_FAKE_OUTPUT=strategy_v1). Configure the worker to return fixed, schema-valid strategy payload during E2E.\n\nTest flow (happy path)\n1) Auth: Launch browser context authenticated as orgA_user.\n2) Create client (if not seeded) via API POST /clients with org A scope.\n3) Create campaign via API POST /campaigns with client_id and org A scope.\n4) Start planning via API POST /campaigns/{campaign_id}/plan with business_goal_id=goalA. Assert 202/200 and a workflow_run record is created (kind=campaign_planning).\n5) Wait for strategy sheet artifact to be created by the activity:\n   - Poll DB artifacts table for type='strategy_sheet' and campaign_id/client_id OR\n   - Poll workflow_runs/activity_logs for a step indicating build_strategy_sheet_activity completed.\n6) Approve via UI: Navigate to the Workflow approvals UI, locate the new run (filter by campaign/client), open details, submit the Approve Strategy action. Confirm success toast/response.\n7) Verify completion: Poll workflow_runs status=completed (or expected terminal state). Confirm finished_at is set. Confirm strategy_sheet artifact persisted and linked to the correct org/client/campaign. Confirm run logs contain a signal record (approve_strategy_sheet).\n\nAuthorization/negative cases\n- Cross-org isolation: Authenticate as orgB_user.\n  - Ensure the campaign/workflow run from org A is not visible in the approvals UI (or list endpoints). If directly calling signal API for that run, expect 403.\n- Invalid IDs: Attempt to plan a non-existent campaign -> expect 404; attempt to plan a campaign from another org -> expect 403 (through API assertions in test setup phase).\n\nImplementation notes\n- Place environment control in a Playwright globalSetup to start services if not already running (or document manual startup). Require Temporal worker to run with CampaignPlanningWorkflow registered.\n- Leverage Playwrightâ€™s request context for API calls with Bearer token constructed from Clerk session JWT, or rely on cookie-based auth depending on backend configuration.\n- Add robust polling helpers with sensible timeouts (e.g., 60â€“120s) to wait for activity completion and run status transitions.\n- Keep org_id, client_id, campaign_id available across steps; log IDs to aid debugging. On failure, capture screenshots and API traces.\n\nExample code skeleton (abridged)\n- e2e/campaign_planning.spec.ts contains blocks:\n  - beforeAll: create orgA_user/orgB_user sessions; seed or fetch goalA.\n  - test('campaign planning happy path', ...) -> create campaign, start plan, wait artifact, approve via UI, assert terminal status and artifact.\n  - test('cross-org cannot view/approve', ...) -> verify invisibility and 403 on signal.\n",
        "testStrategy": "Environment\n1) Start dependencies: Temporal server + worker (with CampaignPlanningWorkflow registered), backend API, and frontend app. Ensure Clerk publishable and secret keys set. Enable deterministic strategy activity output (e.g., STRATEGY_LLM_PROVIDER=fake).\n2) Verify auth locally: using the backendâ€™s protected endpoint, send a request with a Clerk session token and expect 200.\n\nExecution\n3) Reset and seed data: run scripts/reset_e2e.py and scripts/seed_e2e.py if available. Ensure there is at least one business goal in org A.\n4) Run Playwright tests: npx playwright test e2e/campaign_planning.spec.ts --project=chromium\n\nAssertions (happy path)\n- API POST /campaigns returns 201 with org_id scoped to org A.\n- API POST /campaigns/{id}/plan returns success and a workflow_run (kind=campaign_planning) exists in DB with matching org_id/client_id/campaign_id.\n- The strategy sheet artifact appears in DB with type='strategy_sheet' and contains expected deterministic fields (validate schema keys like objectives, channels, budget, KPIs).\n- Approvals UI lists the workflow run; clicking Approve Strategy returns success (UI toast or 200 from underlying API).\n- Workflow run transitions to completed; finished_at is populated; activity_logs include build_strategy_sheet_activity success and approve_strategy_sheet signal receipt.\n\nAssertions (authorization)\n- As orgB_user, the approvals UI does not show org Aâ€™s run.\n- Direct API attempt to signal approve-strategy for org Aâ€™s run returns 403.\n- Planning a campaign from another org returns 403; planning a non-existent campaign returns 404.\n\nStability checks\n- No console errors in the UI during the flow.\n- All waits use explicit polling with maximum timeout and clear diagnostics. Capture traces on failure (npx playwright test --trace on).",
        "status": "done",
        "dependencies": [
          "20",
          "18",
          "19",
          "23",
          "30"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-11T23:03:28.111Z"
      },
      {
        "id": 35,
        "title": "Onboarding intake form and API to persist client intake before starting workflow",
        "description": "Add a gated onboarding intake flow that collects and persists client information prior to starting the ClientOnboardingWorkflow. Implement backend schemas, repo, and endpoints; integrate a frontend form and gate the Start Onboarding action until intake is marked complete.",
        "details": "Scope\n- Introduce a first-class Onboarding Intake that is created and completed before starting ClientOnboardingWorkflow. Persist intake to DB and make activities read it. Add a comprehensive frontend intake form with validation and autosave.\n\nBackend\n1) Data model and migration\n- Table: client_onboarding_intakes\n  - id (pk), org_id (uuid, fk), client_id (uuid, fk, unique), payload (JSONB, not null, default {}), contact_name (text), contact_email (text), completed_at (timestamptz, nullable), created_by (uuid, fk to users if available), version (int, default 1), created_at, updated_at.\n  - Indexes: unique on (client_id); btree on (org_id, client_id); optional GIN on payload if we foresee filtering.\n- Alembic migration: versions/<timestamp>_add_onboarding_intake.py with upgrade/downgrade.\n\n2) Schemas (Pydantic)\n- app/schemas/onboarding_intake.py\n  - IntakePayload: company_overview, brand_voice, products (list), target_audience, competitors (list), ad_platforms (list[str]), metrics_preferences, attribution_tools, constraints, brand_guidelines_url, assets_links (list[str]), notes (optional). Types are JSON-serializable.\n  - OnboardingIntakeCreate { payload: IntakePayload, contact_name, contact_email }\n  - OnboardingIntakeUpdate { payload?: IntakePayload, contact_name?: str, contact_email?: str }\n  - OnboardingIntakeRead { id, client_id, org_id, payload, contact_name, contact_email, completed: bool, completed_at, version, created_at, updated_at }\n\n3) Repository\n- app/repos/onboarding_intake_repo.py\n  - get_by_client(org_id, client_id) -> Optional[OnboardingIntake]\n  - upsert(org_id, client_id, data: OnboardingIntakeCreate|Update, created_by) -> OnboardingIntake\n  - mark_complete(org_id, client_id) -> OnboardingIntake (sets completed_at if not already set)\n  - raise on cross-org access; optimistic locking by version if provided.\n\n4) Router\n- app/routers/onboarding_intake.py (include in main API)\n  - GET /clients/{client_id}/onboarding/intake -> OnboardingIntakeRead (404 if absent)\n  - POST /clients/{client_id}/onboarding/intake -> create or upsert draft (201 on create, 200 on update)\n  - PATCH /clients/{client_id}/onboarding/intake -> partial update (200)\n  - POST /clients/{client_id}/onboarding/intake/complete -> marks complete (200). Idempotent; returns 200 whether already complete.\n- Authorization & scoping: Clerk-authenticated user; verify user.org_id matches client.org_id; verify user can write to client; audit log entries for create/update/complete.\n\n5) Gate workflow start\n- Update existing start endpoint (POST /clients/{client_id}/onboarding) to require an intake marked complete:\n  - If no intake or intake not complete: return 412 Precondition Failed {code: \"onboarding_intake_incomplete\"}\n  - If complete: proceed to start ClientOnboardingWorkflow as today.\n  - If workflow already active: 409 Conflict {code: \"onboarding_already_started\"}\n\n6) Activities integration (Task 15 alignment)\n- Update app/temporal/activities/client_onboarding_activities.py to use onboarding_intake_repo.get_by_client(...) and pass intake.payload/contact info into LLM prompts and persisted artifacts metadata.\n- Validate presence of completed intake; raise a clear ActivityError if missing (should be prevented by the start gate).\n\nFrontend\n1) Types and API client\n- src/types/onboarding.ts: TS mirrors of IntakePayload and OnboardingIntakeRead.\n- src/api/onboarding.ts: getOnboardingIntake(clientId), upsertOnboardingIntake(clientId, data), completeOnboardingIntake(clientId).\n- Reuse Clerk token injection from useApiClient() (Task 25).\n\n2) UI/UX\n- Add a new Intake step in ClientSetupWizard (before Start Onboarding):\n  - Component: src/components/onboarding/OnboardingIntakeForm.tsx with sections (Company, Products, Audience, Competitors, Platforms, Metrics/Attribution, Constraints, Brand Guidelines/Assets, Contacts, Notes).\n  - Form: react-hook-form + zod schema (mirrors backend). Show per-section validation and friendly errors.\n  - Autosave: debounce 800ms PATCH to upsert; show \"Savingâ€¦/Saved\" status. Persist draft to localStorage as fallback on network errors.\n  - Complete: explicit \"Mark Intake Complete\" button calling POST /complete; show a green checklist badge when complete.\n  - Gate: Disable/hide \"Start Onboarding\" CTA until intake.complete === true. Tooltip explaining prerequisite. On click after completion, call existing POST /clients/{id}/onboarding, then route to the approvals/status view (Task 30).\n  - Accessibility: proper labels, descriptions, and keyboard navigation; large textareas with character counters.\n\n3) Edge cases\n- If intake already complete and onboarding already running, disable edits and show read-only view with banner.\n- Allow edits to draft (not complete) states only. If user tries to re-complete after edits, update then mark complete again.\n- Handle 412 from start endpoint by surfacing an inline callout that links back to the Intake step.\n\nObservability & Ops\n- Add structured logs for intake create/update/complete with org_id, client_id, user_id.\n- Feature flag (optional): ONBOARDING_INTAKE_REQUIRED=true to enforce server-side gating (default true in prod, configurable in dev).\n\nSecurity\n- Validate URLs (guidelines/assets) and emails server-side; strip HTML; size-limit payload. Enforce org-scoped access consistently.\n",
        "testStrategy": "Backend\n1) Migration\n- Run alembic upgrade; verify client_onboarding_intakes table exists with expected columns and unique(client_id). Run downgrade and upgrade again to confirm reversibility.\n\n2) Repository unit tests\n- Create client (org A). upsert draft intake; assert fields persisted; update payload; assert version increments if implemented; mark_complete sets completed_at and is idempotent.\n- Access from another org B should raise authorization error.\n\n3) Router/API tests\n- POST /clients/{id}/onboarding/intake creates draft (201). GET returns it (200). PATCH updates nested payload fields (200).\n- POST /complete returns 200; subsequent POST /complete returns 200 unchanged.\n- Start gate: POST /clients/{id}/onboarding before completion -> 412 with code onboarding_intake_incomplete. After completion -> 202/200 and enqueues workflow. If a workflow is already active -> 409.\n\n4) Activities integration tests\n- Stub onboarding_intake_repo to return a completed intake; run build_client_canon_activity and build_metric_schema_activity; assert they consume payload fields (e.g., brand voice) and include them in prompts/outputs.\n- When repo returns None or incomplete, activity raises a clear error; ensure start gate prevents this path in integration.\n\nFrontend\n5) Component/unit tests\n- zod schema validates required fields; shows per-field errors.\n- Autosave: simulate typing -> debounced PATCH fired once; visual indicator transitions from Saving to Saved.\n- Gate: Start Onboarding button disabled until complete; after calling complete endpoint, button enables and triggers start endpoint.\n- Read-only state when workflow already running.\n\n6) E2E (happy path)\n- With local stack running (API, worker, Temporal, frontend, Clerk):\n  - Create client; navigate to ClientSetupWizard.\n  - Fill intake form minimally; click Mark Intake Complete; verify success banner and that Start button is enabled.\n  - Click Start Onboarding; verify workflow run visible in approvals UI; approve canon and metric schema; artifacts appear.\n- Negative: attempt to start without completing intake -> UI shows error derived from 412; server logs show no workflow started.\n\nNon-functional\n- Verify org scoping: user from org B cannot access org A intake (403/404 masking).\n- Accessibility: run axe against IntakeForm; no critical violations.\n",
        "status": "done",
        "dependencies": [
          "14",
          "15",
          "25"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-11T23:19:36.382Z"
      },
      {
        "id": 36,
        "title": "Enforce onboarding completion before starting Campaign Planning and surface status gating in UI",
        "description": "Block CampaignPlanningWorkflow start until the clientâ€™s onboarding intake is complete and the ClientOnboardingWorkflow has finished, and display clear readiness statuses and gating reasons in the UI.",
        "details": "Scope and goals\n- Enforce a hard backend gate: POST /campaigns/{id}/plan must return a 409 with machine-readable reasons unless the client is fully onboarded.\n- Provide a single source of truth for readiness via a new backend endpoint that aggregates intake and onboarding workflow status.\n- Update the UI to display intake/onboarding statuses, explain gating, and disable the Plan Campaign action until ready.\n\nBackend changes\n1) Readiness service\n- Create app/services/client_readiness.py with function get_client_readiness(org_id: UUID, client_id: UUID) -> ReadinessDTO.\n- ReadinessDTO shape:\n  {\n    \"intake\": \"not_started\" | \"in_progress\" | \"complete\",\n    \"onboarding\": \"not_started\" | \"in_progress\" | \"awaiting_approval\" | \"complete\",\n    \"ready_for_campaign_planning\": bool,\n    \"reasons\": string[]  // e.g., [\"intake_incomplete\", \"onboarding_not_complete\"]\n  }\n- Implementation details:\n  - Intake status: query client_onboarding_intakes (from Task 35) by org_id+client_id.\n    - no row => not_started\n    - row with completed_at is null => in_progress\n    - row with completed_at set => complete\n  - Onboarding status: use workflow_runs (kind=\"client_onboarding\") for the client. Map run.status:\n    - none => not_started\n    - running => in_progress\n    - waiting_signal/pending_approval => awaiting_approval (derive by checking last log/step or status enum if present)\n    - completed => complete\n  - ready_for_campaign_planning = intake == complete AND onboarding == complete.\n  - reasons: build from failing predicates (e.g., if intake != complete add \"intake_incomplete\"; if onboarding != complete add \"onboarding_not_complete\").\n\n2) Readiness API\n- Add GET /clients/{client_id}/readiness (scoped by org). Returns ReadinessDTO.\n- Wire to get_client_readiness. Enforce org scoping/authorization and return 404/403 if client not visible.\n\n3) Enforce gate in Campaigns API\n- Modify POST /campaigns/{id}/plan (routers/campaigns.py from Task 20):\n  - Load campaign by id+org; resolve client_id.\n  - Call get_client_readiness(org_id, client_id).\n  - If ready_for_campaign_planning is false, return HTTP 409 Conflict with body:\n    {\n      \"error\": \"client_not_ready_for_campaign_planning\",\n      \"reasons\": ReadinessDTO.reasons,\n      \"readiness\": ReadinessDTO\n    }\n  - Otherwise proceed to start CampaignPlanningWorkflow as today and return 202/201.\n- Add structured logs for gate decisions and include org_id, client_id, campaign_id.\n\nFrontend changes\n1) Readiness fetch\n- Create a clientReadiness API hook (e.g., useClientReadiness(clientId)) that calls GET /clients/{id}/readiness and returns the DTO; poll every 10s while not ready.\n\n2) Status display components\n- Add a ReadinessStatus component rendering two labeled pills:\n  - Intake: Not started | In progress | Complete\n  - Onboarding: Not started | In progress | Awaiting approval | Complete\n- Place this component on:\n  - Client detail page\n  - Campaign detail/list item where Plan Campaign action is shown\n\n3) Gating UX\n- Disable the Plan Campaign button unless ready_for_campaign_planning is true.\n- If disabled, show tooltip and inline helper text derived from reasons:\n  - intake_incomplete => \"Complete the onboarding intake first\" with link to the intake form (Task 35 route).\n  - onboarding_not_complete => \"Finish client onboarding approvals\" with link to the onboarding approvals UI.\n- Handle 409 responses from POST /campaigns/{id}/plan: surface a toast with the server-provided reasons and keep the button disabled.\n\nSecurity and scoping\n- All readiness checks must be org-scoped using the requesterâ€™s org_id. Never leak cross-org readiness status.\n\nObservability\n- Add metrics counters: client_readiness.checked, client_readiness.blocked, client_readiness.ready.\n- Add debug logs for status transitions and reasons to help support.\n\nMigration/data\n- No new tables required; relies on client_onboarding_intakes (Task 35) and existing workflow_runs records for ClientOnboardingWorkflow (Task 14).\n\nRollout considerations\n- Backend change is backward compatible (new GET endpoint, stricter gate on plan). Coordinate with frontend to deploy UI prior to or with backend gate to avoid sudden UX confusion.\n",
        "testStrategy": "Backend\n1) Unit tests for readiness service (pytest + transactional DB):\n   - No intake row + no onboarding run => intake=not_started, onboarding=not_started, ready=false, reasons include intake_incomplete and onboarding_not_complete.\n   - Intake exists without completed_at => intake=in_progress, ready=false, reasons include intake_incomplete.\n   - Intake complete + onboarding running => onboarding=in_progress, ready=false, reasons include onboarding_not_complete.\n   - Intake complete + onboarding awaiting signal => awaiting_approval, ready=false.\n   - Intake complete + onboarding completed => ready=true, reasons=[].\n2) API tests for GET /clients/{id}/readiness:\n   - Returns 200 and DTO for same-org; 403/404 for cross-org.\n3) API tests for POST /campaigns/{id}/plan gate (extend Task 20 tests):\n   - Given intake incomplete => 409 with error=client_not_ready_for_campaign_planning and reasons contains intake_incomplete.\n   - Given intake complete + onboarding not complete => 409 with reasons contains onboarding_not_complete.\n   - Given both complete => 201/202 and workflow run created.\n   - Verify logs contain gate decision and IDs.\n\nFrontend\n1) Component tests (React Testing Library):\n   - ReadinessStatus renders correct pills for each DTO state.\n   - Plan button disabled when ready=false and enabled when true.\n   - Tooltip and helper text reflect reasons; links point to intake form and onboarding approvals routes.\n2) Integration tests (Playwright):\n   - Mock readiness API to simulate each state; verify UI behavior and disabled/enabled states.\n   - Attempt to plan when backend returns 409; verify toast shows reasons and button stays disabled.\n   - After switching readiness to ready (mock), verify button enables and POST succeeds.\n\nSecurity\n- Tests to ensure readiness endpoint and plan gate are org-scoped (no cross-org leakage or planning allowed).\n",
        "status": "done",
        "dependencies": [
          "35",
          "20",
          "14"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-11T23:19:42.726Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-11T23:19:42.727Z",
      "taskCount": 36,
      "completedCount": 33,
      "tags": [
        "master"
      ],
      "created": "2025-12-12T21:12:33.475Z",
      "description": "Tasks for master context",
      "updated": "2025-12-12T21:12:33.475Z"
    }
  },
  "precanon-market-research": {
    "tasks": [
      {
        "id": 1,
        "title": "Define dataclasses, step config, and file layout for PreCanon Market Research",
        "description": "Create input/output dataclasses, step keys, and prompt mapping. Establish module/file structure for the new workflow and activities.",
        "details": "Create files:\n- app/temporal/workflows/precanon_market_research_workflow.py\n- app/temporal/activities/precanon_research_activities.py\n- app/prompts/precanon_research/ (already contains .md prompt files per PRD)\n\nDefine dataclasses:\n- PreCanonMarketResearchInput(org_id: str, client_id: str, onboarding_payload_id: str)\n- ResearchArtifactRef(step_key: str, doc_url: str, doc_id: str, summary: str, prompt_sha256: str, created_at_iso: str)\n- PreCanonMarketResearchResult(artifacts: list[ResearchArtifactRef], canon_context: dict[str, object])\n\nDefine constants and step config map:\n- PROMPT_DIR = \"app/prompts/precanon_research\"\n- STEP_KEYS = [\"step1_competitor\", \"step3_deep_prompt\", \"step4_deep_run\", \"step6_avatar_brief\", \"step7_offer_brief\", \"step8_necessary_beliefs\", \"step9_i_believe\"]\n- STEP_CONFIG: dict[str, dict] mapping keys to prompt files and required placeholder tokens. Example:\n  {\n    \"step1_competitor\": {\"file\": \"01_competitor_research.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"ONBOARDING_PAYLOAD_ID\",\"BUSINESS_CONTEXT_JSON\"]},\n    \"step3_deep_prompt\": {\"file\": \"03_deep_research_prompt.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP1_SUMMARY\",\"ADS_CONTEXT\"], \"expects_step4_prompt\": true},\n    \"step4_deep_run\": {\"file\": \"04_run_deep_research.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP3_PROMPT\"]},\n    \"step6_avatar_brief\": {\"file\": \"06_avatar_brief.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP4_SUMMARY\"]},\n    \"step7_offer_brief\": {\"file\": \"07_offer_brief.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP6_SUMMARY\"]},\n    \"step8_necessary_beliefs\": {\"file\": \"08_necessary_beliefs_prompt1.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP7_SUMMARY\"]},\n    \"step9_i_believe\": {\"file\": \"09_i_believe_statements.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP8_SUMMARY\"]}\n  }\n\nPseudocode types:\n- Use Python 3.11+ and Temporal Python SDK (temporalio). Keep workflow code deterministic (no I/O, no LLM calls).\n- Use timezone-aware ISO-8601 for timestamps (datetime.now(tz=timezone.utc).isoformat()).",
        "testStrategy": "- Static checks: mypy for dataclass fields and STEP_CONFIG shape.\n- Unit tests verifying PROMPT_DIR exists and expected prompt files are present.\n- Unit tests verifying STEP_CONFIG requires tokens listed in PRD and no extraneous tokens.\n- Snapshot tests for dataclass JSON serialization using asdict to ensure schema alignment.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold modules and files for PreCanon Market Research",
            "description": "Create the initial file/module layout for workflow, activities, and prompts directory without implementing business logic.",
            "dependencies": [],
            "details": "- Create files: app/temporal/workflows/precanon_market_research_workflow.py and app/temporal/activities/precanon_research_activities.py. Ensure app/temporal/workflows/__init__.py and app/temporal/activities/__init__.py exist for package discovery.\n- Verify app/prompts/precanon_research/ exists (per PRD) and keep path stable for imports.\n- In workflow file, add a minimal deterministic class stub (no I/O or network) that imports typing-only references to dataclasses using TYPE_CHECKING to avoid runtime side effects.\n- In activities file, add module docstring and placeholders for future activities (no logic yet) and centralize constants import location decision (this module will host constants and config).\n- Add module-level docstrings noting Python 3.11+ requirement and Temporal determinism constraints.",
            "status": "pending",
            "testStrategy": "- Import smoke test ensures both modules import without side effects.\n- Verify the prompt directory path exists using pathlib in a unit test.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement dataclasses for input, artifact reference, and result",
            "description": "Define strongly-typed, frozen dataclasses to capture workflow I/O and artifact metadata.",
            "dependencies": [
              1
            ],
            "details": "- In a shared module (e.g., app/temporal/activities/precanon_research_activities.py or a new app/temporal/models/precanon.py), define:\n  - @dataclass(frozen=True) class PreCanonMarketResearchInput(org_id: str, client_id: str, onboarding_payload_id: str)\n  - @dataclass(frozen=True) class ResearchArtifactRef(step_key: str, doc_url: str, doc_id: str, summary: str, prompt_sha256: str, created_at_iso: str) with docstring noting timezone-aware ISO-8601 (datetime.now(tz=timezone.utc).isoformat()).\n  - @dataclass(frozen=True) class PreCanonMarketResearchResult(artifacts: list[ResearchArtifactRef], canon_context: dict[str, object]).\n- Provide simple serialization helpers if desired (e.g., to_dict using dataclasses.asdict) without adding runtime dependencies.\n- Add __all__ exports for these types.",
            "status": "pending",
            "testStrategy": "- mypy type-check ensuring field types are correct.\n- Snapshot tests using dataclasses.asdict to verify JSON-serializable shapes and key names.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define PROMPT_DIR, STEP_KEYS, StepKey Literal, and STEP_CONFIG mapping",
            "description": "Add constants and a typed configuration map linking step keys to prompt files and required placeholder tokens.",
            "dependencies": [
              1
            ],
            "details": "- In activities module (or a constants module imported by it), define:\n  - PROMPT_DIR = \"app/prompts/precanon_research\".\n  - StepKey = typing.Literal[\"step1_competitor\",\"step3_deep_prompt\",\"step4_deep_run\",\"step6_avatar_brief\",\"step7_offer_brief\",\"step8_necessary_beliefs\",\"step9_i_believe\"].\n  - STEP_KEYS: list[StepKey] mirroring the Literal order.\n  - StepConfig TypedDict(total=False) with fields: file: str; tokens: list[str]; expects_step4_prompt: bool.\n  - STEP_CONFIG: dict[StepKey, StepConfig] exactly per PRD:\n    {\"step1_competitor\": {\"file\": \"01_competitor_research.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"ONBOARDING_PAYLOAD_ID\",\"BUSINESS_CONTEXT_JSON\"]},\n     \"step3_deep_prompt\": {\"file\": \"03_deep_research_prompt.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP1_SUMMARY\",\"ADS_CONTEXT\"], \"expects_step4_prompt\": True},\n     \"step4_deep_run\": {\"file\": \"04_run_deep_research.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP3_PROMPT\"]},\n     \"step6_avatar_brief\": {\"file\": \"06_avatar_brief.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP4_SUMMARY\"]},\n     \"step7_offer_brief\": {\"file\": \"07_offer_brief.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP6_SUMMARY\"]},\n     \"step8_necessary_beliefs\": {\"file\": \"08_necessary_beliefs_prompt1.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP7_SUMMARY\"]},\n     \"step9_i_believe\": {\"file\": \"09_i_believe_statements.md\", \"tokens\": [\"ORG_ID\",\"CLIENT_ID\",\"BUSINESS_CONTEXT_JSON\",\"STEP8_SUMMARY\"]}}\n- Provide helper: def prompt_path(step: StepKey) -> pathlib.Path = Path(PROMPT_DIR)/STEP_CONFIG[step][\"file\"].",
            "status": "pending",
            "testStrategy": "- mypy validates STEP_CONFIG type against TypedDict and Literal keys.\n- Unit test asserts STEP_KEYS equals list(STEP_CONFIG.keys()) and that each referenced file exists under PROMPT_DIR.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement config validation utilities for tokens and files",
            "description": "Create functions to validate STEP_CONFIG integrity, token sets, and prompt file presence to guard against PRD drift.",
            "dependencies": [
              3,
              1
            ],
            "details": "- Add validate_step_config() utility that checks:\n  - Keys of STEP_CONFIG match STEP_KEYS exactly (no missing/extra keys).\n  - For each step: required fields exist; tokens is non-empty list[str] with no duplicates.\n  - expects_step4_prompt only present for step3_deep_prompt and is True when present.\n  - All prompt files exist at PROMPT_DIR and are readable.\n  - Token names are UPPER_SNAKE_CASE and contain only [A-Z0-9_].\n- Provide validate_placeholders_for_step(step: StepKey, provided: dict[str,str]) -> None that raises on missing or extraneous tokens compared to STEP_CONFIG[step][\"tokens\"].\n- Raise ValueError with actionable messages on failures.",
            "status": "pending",
            "testStrategy": "- Unit tests covering: exact key match; duplicate token detection; invalid token naming; missing file failure; expects_step4_prompt only on step3.\n- Property test over steps ensuring validate_placeholders_for_step rejects missing/extraneous keys.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add tests and static checks for dataclasses, constants, and config",
            "description": "Write pytest suites and enable mypy to enforce dataclass fields, STEP_CONFIG shape, and prompt file existence/token rules.",
            "dependencies": [
              2,
              3,
              4,
              1
            ],
            "details": "- Create tests:\n  - tests/precanon/test_dataclasses.py: construct sample objects; assert dataclasses.asdict snapshot; ensure created_at_iso string formatting expectation (regex for ISO-8601).\n  - tests/precanon/test_step_config.py: assert PROMPT_DIR exists; prompt files exist; STEP_KEYS == list(STEP_CONFIG.keys()); each tokens list matches PRD and contains no extras; expects_step4_prompt only on step3.\n  - tests/precanon/test_validation.py: call validate_step_config(); test validate_placeholders_for_step with good/bad payloads.\n- Add mypy configuration (mypy.ini or pyproject) to strict-check the module where types live and ensure Literal-typed STEP_CONFIG.\n- Add minimal CI job or pre-commit hook entries for mypy and pytest.",
            "status": "pending",
            "testStrategy": "- Run pytest for unit tests and snapshots; run mypy in strict mode on the new modules; ensure tests fail if a prompt file is missing or tokens drift from PRD.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T21:32:43.652Z"
      },
      {
        "id": 2,
        "title": "Implement prompt loader/renderer with SHA-256 hashing",
        "description": "Create a deterministic, simple placeholder renderer and prompt file loader that computes SHA-256 of the raw prompt file.",
        "details": "Add utility functions in app/temporal/activities/precanon_research_activities.py or a helpers module:\n- read_prompt_file(path: str) -> tuple[str, str]: returns (raw_text, sha256_hex)\n  sha256_hex = hashlib.sha256(raw_bytes).hexdigest()\n- render_placeholders(raw_text: str, placeholders: dict[str, str]) -> str\n  Implementation: validate that each placeholder key is in the allowed token set for the step; perform simple string replace on occurrences of '{{KEY}}'. Do not use Jinja; avoid control flow for determinism and simplicity. Validate that all required tokens from STEP_CONFIG[step_key]['tokens'] are provided and raise ValueError otherwise.\n- truncate_bounded(text: str, max_chars: int = 5000) -> str to keep summaries within Temporal limits.\n\nPseudocode:\n\ndef read_prompt_file(path):\n    with open(path, 'rb') as f:\n        data = f.read()\n    return data.decode('utf-8'), hashlib.sha256(data).hexdigest()\n\ndef render_placeholders(raw, values):\n    # assert only allowed placeholders present\n    for k, v in values.items():\n        raw = raw.replace(f\"{{{{{k}}}}}\", str(v))\n    # ensure no unreplaced tokens remain\n    if re.search(r\"\\{\\{[A-Z0-9_]+\\}\\}\", raw):\n        raise ValueError(\"Unfilled placeholders present\")\n    return raw\n",
        "testStrategy": "- Unit tests covering: correct SHA-256 for known input; rendering replaces all placeholders; error on missing token; leaves no '{{...}}' tokens.\n- Fuzz tests for placeholder values containing braces or special characters to ensure safe replacement (not interpreted).\n- Performance test reading all prompt files to ensure I/O is fast; no caching required per PRD but acceptable latency.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create prompt utilities module and baseline scaffolding",
            "description": "Add a dedicated helpers module to host prompt file I/O and rendering utilities with deterministic behavior.",
            "dependencies": [],
            "details": "Create app/temporal/utils/prompt_utils.py (or a helpers submodule) and wire exports. Include imports (hashlib, re, typing). Define TOKEN_PATTERN = re.compile(r\"\\{\\{[A-Z0-9_]+\\}\\}\"). Prepare placeholders for: read_prompt_file, render_placeholders, truncate_bounded. Import STEP_CONFIG from its source (or accept it as an injected dependency). Provide a thin wrapper render_step_placeholders(step_key, raw_text, placeholders) that validates keys via STEP_CONFIG then calls render_placeholders to keep the core function pure and maintain determinism. Add module docstrings and type hints.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement read_prompt_file(path) with SHA-256 hashing",
            "description": "Implement function to read a prompt file as bytes, decode as UTF-8, and compute a SHA-256 hex digest.",
            "dependencies": [
              1
            ],
            "details": "Implement read_prompt_file(path: str) -> tuple[str, str]: open file in 'rb', read all bytes, compute sha256 = hashlib.sha256(data).hexdigest(), decode with 'utf-8' (errors='strict'), and return (text, sha256). Do not normalize line endings; preserve raw content for deterministic hashing. Let filesystem errors propagate (FileNotFoundError, PermissionError) to surface issues cleanly.",
            "status": "pending",
            "testStrategy": "Unit tests: (a) known fixture bytes -> expected hexdigest; (b) ensure text decode equals fixture content; (c) FileNotFoundError raised for missing path; (d) hashing unchanged across repeated reads.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement placeholder validation and rendering",
            "description": "Build deterministic placeholder rendering with validation against step tokens and leftover token detection.",
            "dependencies": [
              1
            ],
            "details": "Add get_allowed_tokens(step_key) -> set[str] reading STEP_CONFIG[step_key]['tokens']. Implement validate_placeholders(step_key, placeholders) to ensure: (1) all required tokens present; (2) no unknown keys outside allowed set; raise ValueError with clear messages. Implement render_placeholders(raw_text: str, placeholders: dict[str, str]) -> str to iteratively replace '{{KEY}}' with str(value) using simple str.replace, ordering keys by descending length to avoid partial overlaps. After replacement, if TOKEN_PATTERN finds any unreplaced tokens, raise ValueError(\"Unfilled placeholders present\"). Provide wrapper render_step_placeholders(step_key, raw_text, placeholders) that calls validate then render. Avoid Jinja or any control flow to keep determinism.",
            "status": "pending",
            "testStrategy": "Unit tests: (a) happy path replaces all placeholders; (b) missing required token -> ValueError; (c) unknown token in placeholders -> ValueError; (d) values containing braces or special characters render literally; (e) no '{{...}}' remains post-render; (f) replacement order stability when keys share prefixes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement truncate_bounded(text, max_chars=5000)",
            "description": "Create a safe truncation utility to bound prompt or summary length within Temporal limits.",
            "dependencies": [
              1
            ],
            "details": "Implement truncate_bounded(text: str, max_chars: int = 5000) -> str. If len(text) <= max_chars, return as-is; else return text[:max_chars]. Operate on Python str (Unicode code points) for determinism. Do not modify whitespace or perform re-encoding. Validate types and raise TypeError for non-str inputs to catch misuse early.",
            "status": "pending",
            "testStrategy": "Unit tests: (a) strings shorter/equal to limit unchanged; (b) longer strings truncated to exact max; (c) multi-byte Unicode (emoji, combining characters) still within char limit; (d) extremely large input performance sanity check.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive tests and fixtures for prompt utilities",
            "description": "Write pytest-based tests and fixtures covering hashing, rendering, validation, and truncation behaviors.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create tests/test_prompt_utils.py with fixtures for small prompt files and placeholder maps. Cover: SHA-256 correctness for known bytes; placeholder end-to-end with render_step_placeholders; error on missing/unknown tokens; detection of unreplaced tokens; fuzz tests where values include '{{', '}}', quotes, and unicode; stability tests across repeated runs. Include a tiny sample STEP_CONFIG for tests. Optionally add a large temporary file for basic performance checks within CI time constraints.",
            "status": "pending",
            "testStrategy": "- Unit tests as above. - Fuzz tests generating random placeholder values containing braces/special chars to ensure deterministic literal replacement. - Negative tests for error conditions. - CI integration to run tests with pytest and coverage.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T21:17:41.718Z"
      },
      {
        "id": 3,
        "title": "Create LLM client wrapper for activities",
        "description": "Provide a resilient async LLM call wrapper used only within activities, with retries, timeouts, and model configuration.",
        "details": "Add app/services/llm_client.py (or reuse existing) with:\n- async def generate_text(prompt: str, *, model: str = \"gpt-4o-mini\", temperature: float = 0.2, max_tokens: int = 4000, timeout_s: int = 120) -> str\n- Implement retry with exponential backoff for transient errors. Ensure deterministic behavior is not required because this runs in activities.\n- Allow model override via environment var LLM_MODEL_PRECANON with safe default.\n- Log request id, but do not log prompt content if sensitive; include prompt_sha256 for traceability.\n- If org policy requires in-house model, route via existing internal LLM gateway (e.g., app.services.ai_gateway.generate).\n\nPseudocode:\nasync def generate_text(prompt, **kw):\n    for attempt in range(3):\n        try:\n            with anyio.fail_after(kw.get('timeout_s', 120)):\n                return await ai_gateway.generate_text(prompt=prompt, model=kw.get('model'), temperature=kw.get('temperature'), max_tokens=kw.get('max_tokens'))\n        except TransientError:\n            await anyio.sleep(2 ** attempt)\n    raise RuntimeError(\"LLM generation failed after retries\")",
        "testStrategy": "- Unit tests with mocked ai_gateway to verify retries, backoff, and timeout behavior.\n- Contract test to ensure wrapper returns string and raises on non-200 responses.\n- Redaction test: logs contain prompt_sha256 but not raw prompt.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold llm_client module and public API",
            "description": "Create the llm client wrapper module and expose a single async function to be used by activities.",
            "dependencies": [],
            "details": "Add app/services/llm_client.py with typed signature: async def generate_text(prompt: str, *, model: str = \"gpt-4o-mini\", temperature: float = 0.2, max_tokens: int = 4000, timeout_s: int = 120) -> str. Include module docstring stating activity-only usage, define DEFAULT_MODEL and ENV_MODEL_VAR = \"LLM_MODEL_PRECANON\", set up a module logger, and export in app/services/__init__.py.",
            "status": "pending",
            "testStrategy": "Static import test and type-check: from app.services.llm_client import generate_text should succeed. Lint for unused exports.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement model resolution and org policy routing helpers",
            "description": "Add helpers to resolve model from env and policy, without changing the public API.",
            "dependencies": [
              1
            ],
            "details": "In app/services/llm_client.py implement _resolve_model(model_arg: str|None) -> str that returns env override (LLM_MODEL_PRECANON) when set, otherwise model_arg or DEFAULT_MODEL. Add _should_force_internal() reading env flags (e.g., LLM_FORCE_INTERNAL or ORG_POLICY_INTERNAL_LLM) as truthy booleans. Implement _effective_model(model_arg) that applies policy (e.g., prefix 'internal:' or map via ai_gateway if needed). Do not alter the public function signature.",
            "status": "pending",
            "testStrategy": "Unit tests patch os.environ to verify precedence: explicit arg beats env, env beats default; when policy flag is set, _effective_model returns forced internal model.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement generate_text with timeout, retries, and transient error handling",
            "description": "Add the core async logic using anyio timeout and exponential backoff around ai_gateway calls.",
            "dependencies": [
              1,
              2
            ],
            "details": "Inside generate_text: compute resolved_model = _effective_model(model). Use anyio.fail_after(timeout_s) per attempt. Call app.services.ai_gateway.generate_text(prompt=prompt, model=resolved_model, temperature=temperature, max_tokens=max_tokens). Catch transient exceptions (e.g., httpx.ConnectError/ReadTimeout, asyncio.TimeoutError, custom ai_gateway.TransientError, 5xx codes if surfaced) and retry up to 3 attempts with exponential backoff (2**attempt with jitter) via anyio.sleep. Do not retry on 4xx or content errors. On exhaustion raise RuntimeError(\"LLM generation failed after retries\"). Always return a str.",
            "status": "pending",
            "testStrategy": "pytest-asyncio tests mocking ai_gateway: (1) success no retry, (2) transient then success (verify call count and backoff), (3) non-transient 4xx raises without retry, (4) overall timeout triggers fail_after cancellation. Patch anyio.sleep to a no-op and assert it was awaited expected times.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add structured, redacted logging with prompt SHA-256 and request correlation",
            "description": "Instrument the wrapper with safe logs that exclude prompt content and include trace fields.",
            "dependencies": [
              3
            ],
            "details": "Compute prompt_sha256 = hashlib.sha256(prompt.encode(\"utf-8\", \"ignore\")).hexdigest(). Generate request_id = uuid4(). Before call: logger.info(\"llm_generate_start\", request_id, model=resolved_model, temperature, max_tokens, timeout_s, attempt, prompt_sha256). After success: logger.info(\"llm_generate_success\", request_id, duration_ms, prompt_sha256). On error: logger.warning(\"llm_generate_retry\"...) for transient and logger.error(\"llm_generate_fail\"...) for final. Never log raw prompt. If ai_gateway returns metadata with a request id, prefer it; otherwise keep the generated id.",
            "status": "pending",
            "testStrategy": "Caplog/structlog capture tests assert that logs contain prompt_sha256 and request_id and never contain the raw prompt substring; success, retry, and failure paths are covered. Verify duration_ms is non-negative.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive unit tests and usage example in an activity",
            "description": "Create tests for behavior, configuration, and logging; add a minimal activity usage example to validate import and async flow.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add tests/services/test_llm_client.py using pytest-asyncio and monkeypatch to stub ai_gateway.generate_text. Cover: returns str on success; retries on transient then succeeds; raises RuntimeError after 3 transients; does not retry on 4xx; enforces timeout; respects LLM_MODEL_PRECANON env; respects policy flag; logs contain prompt_sha256 but not prompt. Include a tiny sample activity function that calls generate_text to ensure intended usage and import path are correct.",
            "status": "pending",
            "testStrategy": "Unit tests with mocks and caplog; measure coverage for llm_client.py core paths. No network calls. Run under CI with PYTHONASYNCIODEBUG=1 to catch leaks.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement document storage helper for research artifacts",
        "description": "Create helper to write artifacts to the Artifacts table/storage with idempotency using workflow_id+step_key, returning doc refs.",
        "details": "Add helper in app/services/docs.py:\n- async def upsert_research_doc(org_id: str, client_id: str, workflow_id: str, step_key: str, title: str, content: str, metadata: dict) -> tuple[str, str]\n- Use unique_key = f\"{workflow_id}:{step_key}\" to upsert for Temporal retry idempotency. Ensure metadata includes 'prompt_sha256', 'step_key', 'workflow_id', 'client_id', 'org_id'.\n- Return (doc_id, doc_url). If using existing document service, pass idempotency_key and tags.\n- Keep content out of workflow state; only store references.\n\nPseudocode:\nasync def upsert_research_doc(...):\n    existing = await artifacts_repo.get_by_unique_key(unique_key)\n    if existing:\n        return existing.id, existing.url\n    doc = await artifacts_repo.create({\n        'org_id': org_id,\n        'client_id': client_id,\n        'title': title,\n        'content': content,\n        'metadata': metadata,\n        'unique_key': unique_key,\n        'tags': ['precanon', step_key]\n    })\n    return doc.id, build_url(doc)\n",
        "testStrategy": "- Unit tests mocking artifacts_repo: verifies upsert semantics and metadata fields.\n- Test that repeated calls with same unique_key return the same doc.\n- Ensure doc_url is well-formed and resolvable via existing routing.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define upsert_research_doc API and enforce required metadata in app/services/docs.py",
            "description": "Create the docs service module and function signature, compute unique_key, validate inputs, and merge required metadata keys.",
            "dependencies": [],
            "details": "Add app/services/docs.py and declare async def upsert_research_doc(org_id: str, client_id: str, workflow_id: str, step_key: str, title: str, content: str, metadata: dict) -> tuple[str, str]. Compute unique_key = f\"{workflow_id}:{step_key}\". Validate non-empty org_id, client_id, workflow_id, step_key, title. Sanitize step_key (e.g., allow [A-Za-z0-9_-]). Merge metadata or {} and ensure it includes prompt_sha256, step_key, workflow_id, client_id, org_id, setting/overwriting with values from args where applicable. Add clear docstring describing return contract (doc_id, doc_url) and idempotency behavior. Do not implement repo calls yet; leave placeholders for repo and URL builder.",
            "status": "pending",
            "testStrategy": "Unit tests (to be expanded later) for unique_key composition and metadata merging; verify validation rejects empty step_key and missing prompt_sha256.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement document URL builder and optional document service client wiring",
            "description": "Add a build_url(doc) helper and integrate optional document service client to support idempotency_key and tags.",
            "dependencies": [
              1
            ],
            "details": "Introduce build_url(doc) that constructs a stable URL like f\"{BASE_APP_URL}/docs/{doc.id}\" using configuration (e.g., settings.DOCS_BASE_URL) with sane fallback (relative path). If an existing document service/client is available, add a thin adapter create_document(...) that accepts idempotency_key and tags; surface it via dependency injection or module-level client in docs.py. Ensure the helper does not perform network I/O for URL formatting and that URLs are deterministic across retries.",
            "status": "pending",
            "testStrategy": "Unit tests for build_url with and without BASE_APP_URL; assert it returns a well-formed, stable URL and preserves path structure.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement idempotent upsert against artifacts_repo with race handling and tagging",
            "description": "Complete upsert_research_doc to fetch by unique_key, create when missing, handle unique constraint races, attach tags, and return (id, url).",
            "dependencies": [
              1,
              2
            ],
            "details": "Wire artifacts_repo into upsert_research_doc. Flow: 1) await artifacts_repo.get_by_unique_key(unique_key); if found, return (existing.id, build_url(existing)). 2) If not found, attempt artifacts_repo.create with fields: org_id, client_id, title, content, metadata (merged from step 1), unique_key, tags=[\"precanon\", step_key]. 3) Wrap create in try/except for IntegrityError/UniqueViolation; on exception, re-fetch by unique_key and return existing. Ensure content is only stored in Artifacts storage and never added to workflow state (function returns only id and url). Add structured debug logging around decisions. Maintain Temporal retry safety by making operation idempotent via unique_key and by catching duplicate-key races.",
            "status": "pending",
            "testStrategy": "Verified by subtask 4 tests; specifically cover both happy-path create and IntegrityError fallback to ensure idempotency.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add unit tests for upsert_research_doc: idempotency, metadata, tags, URL",
            "description": "Write async pytest tests mocking artifacts_repo and optional document service to validate behavior and contract.",
            "dependencies": [
              3
            ],
            "details": "Create tests in tests/services/test_docs.py using pytest-asyncio. Cases: (a) Existing doc: get_by_unique_key returns a record -> function returns same id/url, no create called. (b) New doc: get_by_unique_key None then create returns record -> assert create called with unique_key, merged metadata containing prompt_sha256, step_key, workflow_id, client_id, org_id, and tags [\"precanon\", step_key]; assert URL format via build_url. (c) Duplicate race: create raises IntegrityError -> function re-fetches by unique_key and returns existing id/url. (d) Validation: bad step_key or missing prompt_sha256 -> raises ValueError. Also assert repeated calls with same inputs return the same id. Use AsyncMock for repo and patch build_url to a deterministic function for assertions.",
            "status": "pending",
            "testStrategy": "pytest + pytest-asyncio; 100% branch coverage on helper; parameterized tests for step_key variants and URL base config.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export helper, integrate sample usage, and document configuration",
            "description": "Export the helper, provide a usage example in the research activity, document required metadata and idempotency, and ensure settings are wired.",
            "dependencies": [
              4
            ],
            "details": "Export upsert_research_doc via app/services/__init__.py. Add a small usage snippet in generate_research_step_artifact_activity demonstrating calling the helper and passing metadata fields including prompt_sha256. Document in README/ADR: required metadata keys, unique_key format, tags policy, and that only references (id/url) are returned to workflow state. Add settings entry for DOCS_BASE_URL and wire into build_url. Run lint and mypy to ensure typing is correct. Optionally include a minimal in-memory repo stub for local smoke testing in dev docs.",
            "status": "pending",
            "testStrategy": "Smoke test using an in-memory repo stub to ensure end-to-end call returns (doc_id, doc_url) and that DOCS_BASE_URL configuration is respected.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T21:33:02.351Z"
      },
      {
        "id": 5,
        "title": "Implement fetch_onboarding_payload_activity (bounded payload)",
        "description": "Activity to fetch onboarding payload and return a compact, bounded business context JSON for prompts.",
        "details": "In app.temporal.activities.precanon_research_activities:\n@activity.defn(name=\"fetch_onboarding_payload_activity\")\nasync def fetch_onboarding_payload_activity(params: dict) -> dict:\n- Inputs: {org_id, client_id, onboarding_payload_id}\n- Fetch onboarding payload from existing repository (e.g., onboarding_repo.get_by_id).\n- Build BUSINESS_CONTEXT_JSON: include only fields needed for research (industry, product_name, price_points, audience_notes, goals). Truncate long fields and strip binary/PII.\n- Return a bounded dict { 'business_context': {...} } suitable for direct JSON serialization into prompts.\n- Enforce size limit: json.dumps(context) <= 50 KB. If larger, drop least critical fields.\n- All I/O here (DB/network).",
        "testStrategy": "- Unit tests with fixture payloads: verify truncation and bounding (<50KB), and PII stripping.\n- Contract test for schema of return value.\n- Negative tests: nonexistent onboarding_payload_id raises a retriable error, handled at workflow level via retry policy.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define allowlist, truncation limits, and PII/binary sanitizers for business context",
            "description": "Create constants and helper utilities to strictly control which fields are included and how text is cleaned before serialization.",
            "dependencies": [],
            "details": "Add in precanon_research_activities helpers: (1) Allowed output fields: industry, product_name, price_points, audience_notes, goals. (2) Truncation limits: industry<=120 chars; product_name<=200; goals<=10 items each<=280 chars; audience_notes<=10 items/lines each<=500 chars; price_points<=8 items with notes<=200 chars. (3) PII regexes for emails, phone numbers, credit card-like numbers, and URLs; replace matches with '[REDACTED]'. (4) Binary stripping: treat bytes as '[BINARY]', and for strings remove non-printable/control characters. (5) Utility functions: sanitize_text(str)->str, sanitize_list(list[str])->list[str], sanitize_price_points(list[dict])->list[dict]. (6) MAX_JSON_BYTES=50*1024 constant and FIELD_PRIORITY=['audience_notes','goals','price_points'] for later bounding.",
            "status": "pending",
            "testStrategy": "Unit tests: sanitizer removes emails/phones/URLs/CCNs; bytes replaced; control characters removed; strings cut to limits; lists trimmed to limits.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement onboarding payload loader with input validation and retryable error mapping",
            "description": "Add an async function to fetch the onboarding payload from the repository and validate required parameters.",
            "dependencies": [],
            "details": "Create load_onboarding_payload(org_id, client_id, onboarding_payload_id, repo) that: (1) Validates params present and of correct primitive types. (2) Calls await onboarding_repo.get_by_id(org_id, client_id, onboarding_payload_id). (3) If not found or repo returns None, raise temporalio.exceptions.ApplicationError('Onboarding payload not found', non_retryable=False). (4) For transient DB/network exceptions, re-raise to allow Temporal retries. (5) Return the raw payload dict. Include minimal typing hints and clear docstring.",
            "status": "pending",
            "testStrategy": "Unit tests: missing params -> ValueError; nonexistent id -> ApplicationError retriable; happy path returns fixture; repo exceptions bubble for retry.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Assemble sanitized BUSINESS_CONTEXT_JSON from raw onboarding payload",
            "description": "Map and normalize repository data into a compact business_context dict using the sanitizers and allowlist.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement build_business_context(raw_payload) that: (1) Extracts only allowed fields. (2) Coerces price_points into a list of dicts with allowed keys (name, price/amount, currency, notes), removing extraneous keys. (3) Sanitizes and truncates strings and lists via helpers from subtask 1. (4) Converts unsupported types (e.g., Decimal) to JSON-safe primitives. (5) Returns {'business_context': {...}} with deterministic key ordering. (6) Never includes org_id, client_id, emails, phone numbers, or other PII; anything detected is redacted.",
            "status": "pending",
            "testStrategy": "Unit tests: given rich raw payload, ensure only allowed keys appear; values sanitized and truncated; price_points normalized; PII redacted; binary fields excluded.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement JSON size-bounding utility with prioritized field dropping (<= 50KB)",
            "description": "Create a function that ensures the serialized business_context JSON stays within 50KB by iterative trimming and field dropping.",
            "dependencies": [
              1,
              3
            ],
            "details": "Add enforce_size_bound(ctx_dict)->dict that: (1) Serializes with json.dumps(ctx_dict, ensure_ascii=False, separators=(',', ':'), sort_keys=True) and checks byte length <= MAX_JSON_BYTES. (2) If too large, iteratively trim: first shrink per-field truncation thresholds by 50% and re-sanitize; then drop fields by FIELD_PRIORITY order: audience_notes, goals, and then reduce price_points to minimal shape (name and price only), and finally drop price_points if still too large. (3) As a last resort, keep only industry and product_name (truncated) to guarantee bound. (4) Log which fields were dropped for observability. (5) Return the bounded dict.",
            "status": "pending",
            "testStrategy": "Synthetic tests: generate oversized payloads to force each trimming phase; assert final dumps size <= 50KB and that industry/product_name remain; verify dropping order is respected and deterministic.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Wire up fetch_onboarding_payload_activity and add end-to-end tests",
            "description": "Implement the Temporal activity function to load, assemble, bound, and return the final business_context payload with logging and metrics.",
            "dependencies": [
              2,
              3,
              4,
              1
            ],
            "details": "In app.temporal.activities.precanon_research_activities, implement @activity.defn(name='fetch_onboarding_payload_activity') async def fetch_onboarding_payload_activity(params): (1) Validate params contain org_id, client_id, onboarding_payload_id. (2) Load raw payload via subtask 2. (3) Build sanitized context via subtask 3. (4) Apply size bound via subtask 4. (5) Return bounded dict suitable for JSON prompts. (6) Add activity.logger debug entries with sizes before/after, and warnings when dropping fields. (7) Ensure no non-deterministic behavior beyond allowed I/O and that output schema is stable.",
            "status": "pending",
            "testStrategy": "- Unit tests with fixtures: verify truncation, <=50KB bound, and PII stripping. - Contract test: assert return shape is {'business_context': {...}} and keys subset of allowlist. - Negative test: nonexistent onboarding_payload_id raises retriable ApplicationError. - Optional async test invoking the activity with a mocked repo to validate logging and deterministic output for same input.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement get_ads_context_stub_activity (step 2 stub)",
        "description": "Activity returns a small stub ads context as per non-goals (no scraping).",
        "details": "In app.temporal.activities.precanon_research_activities:\n@activity.defn(name=\"get_ads_context_stub_activity\")\nasync def get_ads_context_stub_activity(params: dict) -> dict:\n- Return {'ads_context': 'No ad scraping implemented. Use any available internal notes or examples if present.'}\n- Keep payload very small (<1KB).",
        "testStrategy": "- Unit test verifying fixed small response shape and size.\n- Integration test confirms activity is callable with params and deterministic output.",
        "priority": "low",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Temporal activity get_ads_context_stub_activity with fixed minimal response",
            "description": "Create the activity in the precanon_research_activities module that returns the fixed stub ads context and ignores input params.",
            "dependencies": [],
            "details": "In app/temporal/activities/precanon_research_activities.py: import temporalio.activity and define @activity.defn(name=\"get_ads_context_stub_activity\"). Implement async def get_ads_context_stub_activity(params: dict) -> dict that returns {'ads_context': 'No ad scraping implemented. Use any available internal notes or examples if present.'}. Add type hints and a short docstring. Do not perform any network or I/O. Ensure deterministic behavior by not using time or randomness.",
            "status": "pending",
            "testStrategy": "Manual sanity check in REPL or script: import function and assert return value equals the fixed dict.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add payload size guard and result typing to ensure <1KB output",
            "description": "Introduce a small helper to enforce a hard payload size limit and add a TypedDict for the activity result.",
            "dependencies": [
              1
            ],
            "details": "Add helper ensure_small_payload(obj: Mapping, max_bytes: int = 1024) that json.dumps(obj, ensure_ascii=True, separators=(',',':')) and checks len(encoded) < max_bytes; raise ValueError otherwise. Use the helper in get_ads_context_stub_activity before returning. Define a TypedDict AdsContextResult with field 'ads_context': str to document the contract. Keep message constant to guarantee size compliance.",
            "status": "pending",
            "testStrategy": "Unit tests for ensure_small_payload: verify under/over threshold behavior; test that the activityâ€™s constant output passes the size check.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Register activity in worker and export from activities package",
            "description": "Expose the new activity to the Temporal worker and make it importable from the activities package.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update worker startup (e.g., app/temporal/worker.py or wherever Worker is created) to include get_ads_context_stub_activity in the activities list. Ensure import path points to precanon_research_activities.get_ads_context_stub_activity. Update app/temporal/activities/__init__.py to export the symbol. Verify the registered name matches the decorator name 'get_ads_context_stub_activity'.",
            "status": "pending",
            "testStrategy": "Smoke test worker startup locally to ensure no import errors and the activity appears in logs/metrics when registered.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write unit tests for fixed shape, determinism, and size bound",
            "description": "Add pytest unit tests validating response shape, determinism, and payload size remains under 1KB.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create tests/temporal/activities/test_get_ads_context_stub_activity.py using pytest and pytest-asyncio. Tests: (1) returns a dict with only 'ads_context' key and exact expected string; (2) repeated calls return identical objects; (3) json-encoded size using the same separators is < 1024 bytes; (4) direct tests for ensure_small_payload threshold behavior. No network calls, pure unit tests importing the function.",
            "status": "pending",
            "testStrategy": "Run pytest -q; ensure coverage of success path and size guard helper. Use snapshots or direct equality assertions for deterministic output.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integration test in Temporal TestEnvironment to execute activity by name",
            "description": "Run the activity within a Temporal TestEnvironment/Worker and verify callable by name, parameters ignored, and deterministic output.",
            "dependencies": [
              3,
              4
            ],
            "details": "Using temporalio.testing.WorkflowEnvironment (or TestEnvironment), spin up an in-memory environment and a Worker that registers get_ads_context_stub_activity. Execute the activity by name 'get_ads_context_stub_activity' with arbitrary params. Assert the result matches the fixed dict and that the JSON-encoded payload size is < 1KB. Include a short timeout and default RetryPolicy to validate callability. Tear down the environment cleanly.",
            "status": "pending",
            "testStrategy": "Automated integration test that boots a Worker and runs execute_activity; assert exact response and size constraints. Ensure test passes consistently across runs.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement generate_research_step_artifact_activity",
        "description": "Single activity to load prompt, render placeholders, call LLM, parse tagged blocks, and write a new document per step.",
        "details": "In app.temporal.activities.precanon_research_activities:\n@activity.defn(name=\"generate_research_step_artifact_activity\")\nasync def generate_research_step_artifact_activity(params: dict) -> dict:\n- Params: {org_id, client_id, onboarding_payload_id, workflow_id, step_key, placeholders: dict}\n- Resolve file = os.path.join(PROMPT_DIR, STEP_CONFIG[step_key]['file'])\n- raw, prompt_sha256 = read_prompt_file(file)\n- rendered = render_placeholders(raw, placeholders)\n- response_text = await llm_client.generate_text(rendered, model=os.getenv('LLM_MODEL_PRECANON','gpt-4o-mini'), temperature=0.2, max_tokens=4000)\n- Parse tag blocks using regex with DOTALL:\n  summary = re.search(r\"<SUMMARY>([\\s\\S]*?)</SUMMARY>\", response_text).group(1).strip()\n  content = re.search(r\"<CONTENT>([\\s\\S]*?)</CONTENT>\", response_text).group(1).strip()\n  step4_prompt = None\n  if STEP_CONFIG[step_key].get('expects_step4_prompt'):\n      m = re.search(r\"<STEP4_PROMPT>([\\s\\S]*?)</STEP4_PROMPT>\", response_text)\n      if not m: raise ValueError('Missing <STEP4_PROMPT> block')\n      step4_prompt = m.group(1).strip()\n- title = f\"{step_key} | {client_id} | {workflow_id}\"\n- doc_id, doc_url = await upsert_research_doc(org_id, client_id, workflow_id, step_key, title, content, {\n    'prompt_sha256': prompt_sha256,\n    'step_key': step_key,\n    'workflow_id': workflow_id\n  })\n- created_at_iso = datetime.now(timezone.utc).isoformat()\n- Return: {\n    'doc_id': doc_id, 'doc_url': doc_url, 'summary': truncate_bounded(summary, 5000), 'prompt_sha256': prompt_sha256, 'created_at_iso': created_at_iso, 'step_key': step_key, 'handoff': {'STEP3_PROMPT': step4_prompt} if step4_prompt else None\n  }\n\nNotes:\n- All I/O happens in this activity (file read, LLM, storage). Workflow only receives bounded summaries and refs.\n- Ensure errors include prompt_sha256 and step_key for traceability.",
        "testStrategy": "- Unit tests: parsing regex extracts SUMMARY/CONTENT and optional STEP4_PROMPT; errors when tags are missing.\n- Integration tests: mock LLM to return deterministic tagged output; verify document creation and idempotent retries.\n- Size tests: ensure returned summary is truncated to <= 5k chars.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create activity skeleton and validate input parameters",
            "description": "Define the Temporal activity function with the specified name and validate required params before any I/O.",
            "dependencies": [],
            "details": "Add @activity.defn(name=\"generate_research_step_artifact_activity\") and async def generate_research_step_artifact_activity(params: dict) -> dict. Validate presence and types for org_id, client_id, onboarding_payload_id, workflow_id, step_key, and placeholders (must be dict). Verify step_key exists in STEP_CONFIG. Prepare a context dict containing step_key for logging. Use structured logging for start/end. On validation failure, raise an ApplicationError (non-retryable) containing step_key so errors are traceable.",
            "status": "pending",
            "testStrategy": "Unit tests: missing required keys, wrong types, or unknown step_key produce ApplicationError with step_key present. Happy-path with minimal valid params reaches next stubbed stage (mock subsequent calls).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Resolve prompt file, load raw prompt, compute SHA-256, and render placeholders",
            "description": "Implement prompt path resolution, file read via helper, and placeholder rendering using provided utilities.",
            "dependencies": [
              1
            ],
            "details": "Resolve file path as os.path.join(PROMPT_DIR, STEP_CONFIG[step_key][\"file\"]). Call read_prompt_file(file) to obtain raw and prompt_sha256. Immediately log prompt_sha256 for traceability. Call render_placeholders(raw, placeholders) to get rendered prompt. Wrap this block with try/except to enrich any exception with step_key and prompt_sha256 (if available). Validate rendered contains no unreplaced tokens like \"{{...}}\" if renderer does not already guarantee it.",
            "status": "pending",
            "testStrategy": "Unit tests: mock read_prompt_file to return known raw and hash; ensure correct join path and that prompt_sha256 is propagated to logs/errors. Verify render_placeholders called with the same raw and placeholders. Negative test: missing file or placeholder error raises with step_key and includes prompt_sha256 once computed.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Invoke LLM with deterministic configuration and capture response text",
            "description": "Call llm_client.generate_text with configured model, temperature, and max_tokens; add retry/timeout handling and error context.",
            "dependencies": [
              2
            ],
            "details": "Read model from env LLM_MODEL_PRECANON defaulting to \"gpt-4o-mini\". Await llm_client.generate_text(rendered, model=model, temperature=0.2, max_tokens=4000). Optionally apply a client-level timeout or retry policy appropriate for activities. On exception, raise an ApplicationError including step_key and prompt_sha256 to support traceability. Log response size in characters on success.",
            "status": "pending",
            "testStrategy": "Unit tests: mock llm_client to verify called with expected args and that its return value is passed through. Negative tests: simulated timeout/exception includes step_key and prompt_sha256 in raised error. Env var test: when LLM_MODEL_PRECANON set, the chosen model matches env.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Parse tagged blocks (SUMMARY, CONTENT, optional STEP4_PROMPT) and enforce bounds",
            "description": "Extract required sections using DOTALL regex, validate presence, and truncate summary to 5,000 chars.",
            "dependencies": [
              3
            ],
            "details": "Use non-greedy DOTALL regex to extract <SUMMARY>...</SUMMARY> and <CONTENT>...</CONTENT>. Trim whitespace. If STEP_CONFIG[step_key].get(\"expects_step4_prompt\") is true, require <STEP4_PROMPT>...</STEP4_PROMPT>; else allow it to be absent. On any missing required block, raise a ValueError/ApplicationError enriched with step_key and prompt_sha256. Apply truncate_bounded(summary, 5000). Store parsed fields for persistence and return payload. Log which optional blocks were found.",
            "status": "pending",
            "testStrategy": "Unit tests with deterministic strings: correct extraction, non-greedy behavior, and whitespace trim. Negative tests: missing SUMMARY/CONTENT cause errors. When expects_step4_prompt=true but tag missing, error raised. Size test: summary longer than 5k is truncated to 5k or less.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Upsert research document and build return payload with metadata and handoff",
            "description": "Persist content via upsert_research_doc, then construct and return the specified result object including timestamps and handoff.",
            "dependencies": [
              4
            ],
            "details": "Create title as f\"{step_key} | {client_id} | {workflow_id}\". Call await upsert_research_doc(org_id, client_id, workflow_id, step_key, title, content, {\"prompt_sha256\": prompt_sha256, \"step_key\": step_key, \"workflow_id\": workflow_id}). Compute created_at_iso = datetime.now(timezone.utc).isoformat(). Build the return dict with doc_id, doc_url, summary (already truncated), prompt_sha256, created_at_iso, step_key, and handoff mapping {\"STEP3_PROMPT\": step4_prompt} if present else None. Ensure exceptions from storage also include step_key and prompt_sha256. Log success with doc_id/doc_url.",
            "status": "pending",
            "testStrategy": "Integration-style test with upsert_research_doc mocked: verify correct args, title format, metadata, and that return payload matches schema. Idempotency test: repeated calls with same inputs do not create duplicates (assert upsert behavior called as expected). Verify created_at_iso is UTC ISO-8601. Handoff is None when optional prompt absent and contains STEP4_PROMPT when present.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement PreCanonMarketResearchWorkflow (sequential, deterministic)",
        "description": "Create Temporal workflow to run activities for steps 1, 2 (stub), 3, 4, 6, 7, 8, 9, build artifacts list and canon_context bundle.",
        "details": "In app/temporal/workflows/precanon_market_research_workflow.py:\nfrom temporalio import workflow\nfrom temporalio.common import RetryPolicy\n\n@workflow.defn(name='PreCanonMarketResearchWorkflow')\nclass PreCanonMarketResearchWorkflow:\n    @workflow.run\n    async def run(self, inp: PreCanonMarketResearchInput) -> PreCanonMarketResearchResult:\n        wf_id = workflow.info().workflow_id\n        # 1) Fetch onboarding/business context\n        ctx = await workflow.execute_activity(\n            'fetch_onboarding_payload_activity',\n            {'org_id': inp.org_id, 'client_id': inp.client_id, 'onboarding_payload_id': inp.onboarding_payload_id},\n            start_to_close_timeout=timedelta(minutes=2),\n            retry_policy=RetryPolicy(maximum_attempts=3)\n        )\n        business_json = json.dumps(ctx['business_context'], ensure_ascii=False)\n        # 2) Ads context (stub)\n        ads = await workflow.execute_activity(\n            'get_ads_context_stub_activity',\n            {'org_id': inp.org_id, 'client_id': inp.client_id},\n            start_to_close_timeout=timedelta(seconds=30),\n            retry_policy=RetryPolicy(maximum_attempts=1)\n        )\n        artifacts: list[ResearchArtifactRef] = []\n        canon_context: dict[str, object] = { 'BUSINESS_CONTEXT_JSON': business_json, 'ADS_CONTEXT': ads.get('ads_context') }\n        # 3) Step 1\n        r1 = await workflow.execute_activity('generate_research_step_artifact_activity', {\n            'org_id': inp.org_id, 'client_id': inp.client_id, 'onboarding_payload_id': inp.onboarding_payload_id,\n            'workflow_id': wf_id, 'step_key': 'step1_competitor',\n            'placeholders': {\n                'ORG_ID': inp.org_id,\n                'CLIENT_ID': inp.client_id,\n                'ONBOARDING_PAYLOAD_ID': inp.onboarding_payload_id,\n                'BUSINESS_CONTEXT_JSON': business_json\n            }\n        }, start_to_close_timeout=timedelta(minutes=6), retry_policy=RetryPolicy(maximum_attempts=2))\n        artifacts.append(ResearchArtifactRef('step1_competitor', r1['doc_url'], r1['doc_id'], r1['summary'], r1['prompt_sha256'], r1['created_at_iso']))\n        canon_context['STEP1_SUMMARY'] = r1['summary']\n        # 4) Step 3\n        r3 = await workflow.execute_activity('generate_research_step_artifact_activity', {\n            'org_id': inp.org_id, 'client_id': inp.client_id, 'onboarding_payload_id': inp.onboarding_payload_id,\n            'workflow_id': wf_id, 'step_key': 'step3_deep_prompt',\n            'placeholders': {\n                'ORG_ID': inp.org_id,\n                'CLIENT_ID': inp.client_id,\n                'BUSINESS_CONTEXT_JSON': business_json,\n                'STEP1_SUMMARY': r1['summary'],\n                'ADS_CONTEXT': ads.get('ads_context')\n            }\n        }, start_to_close_timeout=timedelta(minutes=6), retry_policy=RetryPolicy(maximum_attempts=2))\n        artifacts.append(ResearchArtifactRef('step3_deep_prompt', r3['doc_url'], r3['doc_id'], r3['summary'], r3['prompt_sha256'], r3['created_at_iso']))\n        canon_context['STEP3_PROMPT'] = (r3.get('handoff') or {}).get('STEP3_PROMPT')\n        # 5) Step 4 (longer timeout)\n        r4 = await workflow.execute_activity('generate_research_step_artifact_activity', {\n            'org_id': inp.org_id, 'client_id': inp.client_id, 'onboarding_payload_id': inp.onboarding_payload_id,\n            'workflow_id': wf_id, 'step_key': 'step4_deep_run',\n            'placeholders': {\n                'ORG_ID': inp.org_id,\n                'CLIENT_ID': inp.client_id,\n                'BUSINESS_CONTEXT_JSON': business_json,\n                'STEP3_PROMPT': canon_context.get('STEP3_PROMPT')\n            }\n        }, start_to_close_timeout=timedelta(minutes=15), retry_policy=RetryPolicy(maximum_attempts=2))\n        artifacts.append(ResearchArtifactRef('step4_deep_run', r4['doc_url'], r4['doc_id'], r4['summary'], r4['prompt_sha256'], r4['created_at_iso']))\n        canon_context['STEP4_SUMMARY'] = r4['summary']\n        # 6) Step 6\n        async def run_step(step_key, needed_key, needed_value):\n            res = await workflow.execute_activity('generate_research_step_artifact_activity', {\n                'org_id': inp.org_id, 'client_id': inp.client_id, 'onboarding_payload_id': inp.onboarding_payload_id,\n                'workflow_id': wf_id, 'step_key': step_key,\n                'placeholders': {\n                    'ORG_ID': inp.org_id,\n                    'CLIENT_ID': inp.client_id,\n                    'BUSINESS_CONTEXT_JSON': business_json,\n                    needed_key: needed_value\n                }\n            }, start_to_close_timeout=timedelta(minutes=6), retry_policy=RetryPolicy(maximum_attempts=2))\n            artifacts.append(ResearchArtifactRef(step_key, res['doc_url'], res['doc_id'], res['summary'], res['prompt_sha256'], res['created_at_iso']))\n            return res['summary']\n        canon_context['STEP6_SUMMARY'] = await run_step('step6_avatar_brief', 'STEP4_SUMMARY', r4['summary'])\n        canon_context['STEP7_SUMMARY'] = await run_step('step7_offer_brief', 'STEP6_SUMMARY', canon_context['STEP6_SUMMARY'])\n        canon_context['STEP8_SUMMARY'] = await run_step('step8_necessary_beliefs', 'STEP7_SUMMARY', canon_context['STEP7_SUMMARY'])\n        canon_context['STEP9_SUMMARY'] = await run_step('step9_i_believe', 'STEP8_SUMMARY', canon_context['STEP8_SUMMARY'])\n        # Return only bounded summaries and refs to keep history << 2MB\n        return PreCanonMarketResearchResult(artifacts=artifacts, canon_context=canon_context)",
        "testStrategy": "- Temporal workflow unit tests using the Temporal Python TestEnvironment: mock activities to return small payloads and verify sequence and passing of handoffs.\n- Determinism test: assert no workflow code performs I/O (static check) and replay test with recorded history.\n- Size test: assert len(json.dumps(asdict(result))) < 200KB for safety.",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define workflow I/O dataclasses and helpers for bounded summaries",
            "description": "Create serializable types used by the workflow and a small helper to bound string sizes to keep history small.",
            "dependencies": [],
            "details": "Add new module app/temporal/models/precanon.py with dataclasses: PreCanonMarketResearchInput {org_id:str, client_id:str, onboarding_payload_id:str}, ResearchArtifactRef {step_key, doc_url, doc_id, summary, prompt_sha256, created_at_iso}, and PreCanonMarketResearchResult {artifacts:list[ResearchArtifactRef], canon_context:dict[str, object]}. Add helper bound_str(s: str, max_len: int = 5000) -> str that returns s[:max_len] if s is longer, and a bound_dict_values(d: dict, keys: list[str], max_len: int) to trim selected keys. Export via __all__. Ensure all fields are JSON-serializable.",
            "status": "pending",
            "testStrategy": "Unit tests: construct each dataclass and ensure asdict() or dataclasses.asdict produces JSON-serializable structures; test bound_str trims exactly; fuzz test with multibyte characters to ensure slicing stays valid.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement workflow skeleton and steps 1â€“2 with context initialization",
            "description": "Write PreCanonMarketResearchWorkflow.run to start workflow, call context activities for steps 1 and 2, and initialize artifacts and canon_context.",
            "dependencies": [
              1
            ],
            "details": "In app/temporal/workflows/precanon_market_research_workflow.py implement the class with @workflow.defn(name='PreCanonMarketResearchWorkflow'). Import json, timedelta, RetryPolicy, types from models. In run(), get wf_id = workflow.info().workflow_id. Execute 'fetch_onboarding_payload_activity' with timeouts/retry policy; JSON-dump ctx['business_context'] deterministically (ensure_ascii=False, sort_keys=True). Execute 'get_ads_context_stub_activity' with short timeout and 1 attempt. Initialize artifacts: list[ResearchArtifactRef] = []. Initialize canon_context with BUSINESS_CONTEXT_JSON (possibly bounded via helper) and ADS_CONTEXT. Do not perform any non-deterministic I/O or logging with timestamps.",
            "status": "pending",
            "testStrategy": "Use mocked activities to return small dicts. Assert canon_context contains BUSINESS_CONTEXT_JSON and ADS_CONTEXT, and that JSON dump is stable across runs (sort_keys=True). Verify no random/time calls via a simple grep/static check in tests.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Orchestrate steps 3 and 4: generate artifacts and handoff prompt",
            "description": "Call generate_research_step_artifact_activity for step1, step3, and step4 with correct placeholders, timeouts, and retry policies. Update artifacts and canon_context.",
            "dependencies": [
              2
            ],
            "details": "Implement step1 (key 'step1_competitor') with placeholders ORG_ID, CLIENT_ID, ONBOARDING_PAYLOAD_ID, BUSINESS_CONTEXT_JSON. Append ResearchArtifactRef with fields from result. Set canon_context['STEP1_SUMMARY'] = bounded summary. Implement step3 (key 'step3_deep_prompt') with placeholders ORG_ID, CLIENT_ID, BUSINESS_CONTEXT_JSON, STEP1_SUMMARY, ADS_CONTEXT, append artifact, and extract handoff prompt from r3.get('handoff', {}).get('STEP3_PROMPT') into canon_context['STEP3_PROMPT'] (allow None). Implement step4 (key 'step4_deep_run') with placeholders ORG_ID, CLIENT_ID, BUSINESS_CONTEXT_JSON, STEP3_PROMPT, longer timeout (15m), append artifact, and set canon_context['STEP4_SUMMARY'] with bounding helper.",
            "status": "pending",
            "testStrategy": "Mock activity to return deterministic dicts including a handoff for step3; assert artifacts length grows to 3 and keys STEP1_SUMMARY, STEP3_PROMPT, STEP4_SUMMARY exist; verify timeouts/retries configured by introspecting workflow code or by injecting an activity that records StartToClose timeout via side channel in tests.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Orchestrate steps 6â€“9 and finalize result with bounded canon_context",
            "description": "Add reusable inner run_step helper and sequentially execute steps 6, 7, 8, 9, wiring summaries through placeholders. Return PreCanonMarketResearchResult with only needed data.",
            "dependencies": [
              3
            ],
            "details": "Inside run(), define async run_step(step_key, needed_key, needed_value) that calls the shared activity with ORG_ID, CLIENT_ID, BUSINESS_CONTEXT_JSON, and the needed handoff key/value. For each step: step6_avatar_brief needs STEP4_SUMMARY; step7_offer_brief needs STEP6_SUMMARY; step8_necessary_beliefs needs STEP7_SUMMARY; step9_i_believe needs STEP8_SUMMARY. Append each artifact, bound and store the returned summary in canon_context under STEP6_SUMMARYâ€¦STEP9_SUMMARY. Before returning, optionally bound long canon_context string values using helper, and ensure artifacts list contains only refs (no large content). Return PreCanonMarketResearchResult(artifacts, canon_context). Preserve determinism: no randomness, env reads, or time-based logic.",
            "status": "pending",
            "testStrategy": "Mock activity to record call order into a shared list; assert exact order: 1,2,step1,step3,step4,step6,step7,step8,step9. Verify chaining: each stepâ€™s placeholder includes the prior summary. Assert summaries are bounded by helper. Validate artifacts length is 7 and step keys match.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Temporal TestEnvironment workflow tests for sequence, determinism, retries, and size",
            "description": "Create comprehensive tests that run the workflow with mocked activities to validate sequence, handoffs, retries, and bounded output size.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add tests under tests/temporal/workflows/test_precanon_market_research_workflow.py. Use Temporal Python testing utilities to start a test environment and a Worker that registers PreCanonMarketResearchWorkflow and mock activities for the three activity names. Mocks: fetch_onboarding_payload_activity returns minimal business_context; get_ads_context_stub_activity returns fixed small ads_context; generate_research_step_artifact_activity returns deterministic outputs by step_key (include handoff STEP3_PROMPT for step3; for retry test, make the first call for a chosen step raise an exception then succeed). Assertions: activity invocation order; correct placeholders passed (capture in mock); canon_context keys present and chained; artifacts count 7 with expected step_keys; no non-deterministic imports or calls (static lint or monkeypatch random/time to raise); final serialized result size << 2MB. Include a replay-style test by running the workflow twice with same mocks and asserting identical results.",
            "status": "pending",
            "testStrategy": "Integration tests with Temporal TestEnvironment and Worker; unit tests for bounding and order; negative test for missing handoff to ensure None is handled without crash; retry test verifying two attempts on the configured step and that workflow succeeds.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T21:34:03.268Z"
      },
      {
        "id": 9,
        "title": "Update client_onboarding_activities to accept precanon canon_context and persist research refs",
        "description": "Extend build_client_canon_activity to accept and use research canon_context; update persist_client_onboarding_artifacts_activity to store research artifact refs with prompt hashes.",
        "details": "In app.temporal.activities.client_onboarding_activities:\n- Modify build_client_canon_activity signature to include precanon_context (dict) parameter. Keep backward compatibility by reading from kwargs or default {}.\n- Use precanon_context fields (e.g., STEP6_SUMMARY, STEP7_SUMMARY) to enrich canon generation logic where applicable. Do not fetch large docs; only use summaries.\n- Update persist_client_onboarding_artifacts_activity to accept research_artifacts: list[ResearchArtifactRef-like dict] and store into onboarding artifacts/metrics schema with fields: step_key, doc_id, doc_url, summary, prompt_sha256, created_at_iso. Ensure idempotency keys reference onboarding_payload_id + step_key.\n- Ensure no workflow code is changed here; these are activities.\n\nPseudocode:\n@activity.defn\nasync def build_client_canon_activity(params):\n    precanon = params.get('precanon_context', {})\n    # pass precanon context into canon builder domain logic\n    canon = await canon_service.build(params['org_id'], params['client_id'], context=precanon)\n    return canon\n\n@activity.defn\nasync def persist_client_onboarding_artifacts_activity(params):\n    for ref in params['research_artifacts']:\n        await onboarding_artifacts_repo.upsert({\n            'onboarding_payload_id': params['onboarding_payload_id'],\n            'step_key': ref['step_key'],\n            'doc_id': ref['doc_id'],\n            'doc_url': ref['doc_url'],\n            'summary': ref['summary'],\n            'prompt_sha256': ref['prompt_sha256'],\n            'created_at_iso': ref['created_at_iso']\n        })\n    return {'stored': len(params['research_artifacts'])}",
        "testStrategy": "- Unit tests for activity signatures and persistence semantics; verify upsert prevents duplicate entries on retries.\n- Integration test where a fake precanon_context influences canon building (e.g., ensure passed through to service).\n- Schema tests to ensure all required fields (including prompt_sha256) are written.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define params schema and update activity interfaces for backward compatibility",
            "description": "Introduce clear schemas for precanon_context and research_artifacts and update activity function signatures to remain backward compatible.",
            "dependencies": [],
            "details": "Create TypedDicts (or Pydantic models if used) for PrecanonContext and ResearchArtifactRef with fields: step_key, doc_id, doc_url, summary, prompt_sha256, created_at_iso. Update build_client_canon_activity signature to accept precanon_context: Optional[dict]=None in addition to legacy single-params dict. Update persist_client_onboarding_artifacts_activity to accept research_artifacts: Optional[List[dict]]=None. Implement coalescing logic: explicit kwarg > params['precanon_context'] > kwargs.get('precanon_context') > {}. For research_artifacts, accept either explicit arg or params['research_artifacts']. Do not change any workflow code; only adjust activities to tolerate both call styles. Add lightweight validation and normalization helpers (e.g., ensure created_at_iso is ISO8601 string).",
            "status": "pending",
            "testStrategy": "Unit tests that call activities with: (a) only params dict, (b) explicit kwargs, and (c) mixed kwargs to confirm precedence and defaults. Validate schema normalization of created_at_iso and required keys.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Modify build_client_canon_activity to pass precanon_context into canon builder",
            "description": "Implement logic to enrich and pass summaries-only precanon_context to canon_service.build without fetching large docs.",
            "dependencies": [
              1
            ],
            "details": "Inside build_client_canon_activity, coalesce precanon_context via helper from subtask 1. Whitelist only summary-safe fields (e.g., STEP6_SUMMARY, STEP7_SUMMARY) before passing to canon_service.build(org_id, client_id, context=filtered_precanon). Preserve return shape. Maintain signature compatibility and avoid any workflow changes. Add structured logging for presence of context (not content). Ensure function remains idempotent and side-effect free.",
            "status": "pending",
            "testStrategy": "Integration-style unit test with a stub canon_service that records received context; assert STEP6_SUMMARY/STEP7_SUMMARY are present and no unexpected large fields are passed. Backward-compat test: calling without precanon_context still builds canon.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extend onboarding_artifacts_repo with idempotent upsert using onboarding_payload_id+step_key",
            "description": "Add repository method and storage semantics to persist research artifact refs with idempotency keyed by onboarding_payload_id and step_key.",
            "dependencies": [
              1
            ],
            "details": "Implement onboarding_artifacts_repo.upsert(payload) that stores fields: onboarding_payload_id, step_key, doc_id, doc_url, summary, prompt_sha256, created_at_iso. Use an UPSERT/ON CONFLICT on composite key (onboarding_payload_id, step_key) to guarantee idempotency on Temporal retries. If schema/index not present, add migration or ensure existing schema supports these fields and unique index. Ensure upsert updates fields atomically and returns affected row count. Include input normalization (truncate overly long strings, enforce ISO8601).",
            "status": "pending",
            "testStrategy": "Repository unit tests: first insert returns 1, repeated insert with same onboarding_payload_id+step_key does not create duplicates and updates fields as expected. Concurrency test with two rapid upserts verifies uniqueness constraint.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement persist_client_onboarding_artifacts_activity to accept and store research_artifacts list",
            "description": "Update activity to process research_artifacts and persist them via the idempotent repo upsert, returning a stored count.",
            "dependencies": [
              3,
              1
            ],
            "details": "Coalesce research_artifacts from explicit arg or params. Validate each dict against ResearchArtifactRef schema and normalize created_at_iso. For each ref, call onboarding_artifacts_repo.upsert with onboarding_payload_id and mapped fields. Ensure idempotency by relying on repo composite key (onboarding_payload_id+step_key). Aggregate a deterministic return payload: {'stored': n}. Add defensive checks for empty lists and missing fields with clear errors. Do not modify any workflow code.",
            "status": "pending",
            "testStrategy": "Activity unit tests: (a) store a list of valid refs returns correct count; (b) retrying the same payload results in no duplicate rows due to upsert and returns same stored count; (c) invalid payloads raise clear exceptions. Mock repo to assert correct mapping.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add targeted tests for activities: signatures, pass-through, and persistence idempotency",
            "description": "Create tests covering signature compatibility, context pass-through to canon builder, and artifact persistence idempotency semantics.",
            "dependencies": [
              2,
              4
            ],
            "details": "Write unit tests for build_client_canon_activity and persist_client_onboarding_artifacts_activity following the projectâ€™s testing stack. Include: backward-compat call styles, filtering of precanon_context to summaries, and repo upsert behavior on retries. Add a lightweight integration test that simulates a fake precanon_context influencing canon building (assert context keys observed by stub service). Ensure tests run in CI and are deterministic (no external I/O).",
            "status": "pending",
            "testStrategy": "- Unit tests for both activities using mocks/stubs; - Idempotency test verifying ON CONFLICT prevents duplicates; - Integration test where a fake precanon_context changes canon_service output; - Negative tests for missing required fields and invalid ISO timestamps.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T21:41:11.478Z"
      },
      {
        "id": 10,
        "title": "Update ClientOnboardingWorkflow to start child PreCanonMarketResearchWorkflow and wire outputs",
        "description": "Modify workflow to trigger PreCanonMarketResearchWorkflow first, then pass canon_context to build_client_canon_activity and persist research artifacts.",
        "details": "In app/temporal/workflows/client_onboarding_workflow.py:\n- Before canon creation, execute child workflow:\n  research = await workflow.execute_child_workflow(\n      'PreCanonMarketResearchWorkflow',\n      PreCanonMarketResearchInput(org_id, client_id, onboarding_payload_id),\n      id=f\"precanon-{workflow.info().workflow_id}\",\n      start_to_close_timeout=timedelta(minutes=45)\n  )\n- Then call build_client_canon_activity with {'precanon_context': research.canon_context, ...}.\n- After canon and metric approvals (unchanged gating), call persist_client_onboarding_artifacts_activity with research.artifacts to store refs alongside canon/metric artifacts.\n- Ensure only refs/summaries flow through workflow state.\n\nPseudocode:\nresearch = await workflow.execute_child_workflow('PreCanonMarketResearchWorkflow', input)\ncanon = await workflow.execute_activity('build_client_canon_activity', { 'org_id': org_id, 'client_id': client_id, 'precanon_context': research.canon_context }, start_to_close_timeout=timedelta(minutes=10))\nawait workflow.execute_activity('persist_client_onboarding_artifacts_activity', { 'onboarding_payload_id': onboarding_payload_id, 'research_artifacts': [asdict(a) for a in research.artifacts] }, start_to_close_timeout=timedelta(minutes=2))",
        "testStrategy": "- Workflow replay tests to ensure determinism and correct child workflow invocation.\n- End-to-end happy path test with mocked activities verifying that canon activity receives the canon_context and that persist activity is called with artifact refs.\n- Negative test: child workflow failure bubbles up; onboarding workflow retries or surfaces error per policy.",
        "priority": "high",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze ClientOnboardingWorkflow and prepare imports/types for PreCanon integration",
            "description": "Review client_onboarding_workflow.py to identify insertion point before canon creation and required types.",
            "dependencies": [],
            "details": "Open app/temporal/workflows/client_onboarding_workflow.py. Locate current canon creation section. Import PreCanonMarketResearchInput and PreCanonMarketResearchResult from precanon workflow module (or shared types). Plan a workflow.get_version guard (e.g., key \"precanon_child_v1\") to introduce the new child-step without breaking replay. Define minimal in-memory shapes ensuring only summaries/refs (canon_context, artifact refs) are kept in workflow state.",
            "status": "pending",
            "testStrategy": "Static checks: run linter/type-checker; confirm imports resolve and types are serializable for Temporal payloads.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Execute PreCanonMarketResearchWorkflow as child prior to canon creation",
            "description": "Add child workflow execution and capture trimmed result with only refs/summaries.",
            "dependencies": [
              1
            ],
            "details": "Before canon creation, insert: research = await workflow.execute_child_workflow('PreCanonMarketResearchWorkflow', PreCanonMarketResearchInput(org_id, client_id, onboarding_payload_id), id=f\"precanon-{workflow.info().workflow_id}\", start_to_close_timeout=timedelta(minutes=45)). Wrap with workflow.get_version('precanon_child_v1', 1, 1) to gate the new logic. Store only research.canon_context and artifact reference metadata in local vars; avoid large payloads to keep history small and deterministic.",
            "status": "pending",
            "testStrategy": "Temporal unit test to assert child workflow is invoked with correct ID, input, and timeout; replay test to ensure determinism with get_version gate.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wire precanon_context into build_client_canon_activity payload",
            "description": "Modify canon activity call to pass research.canon_context as precanon_context.",
            "dependencies": [
              2
            ],
            "details": "Update the build_client_canon_activity invocation to include {'precanon_context': research.canon_context, ...existing fields...} with start_to_close_timeout=timedelta(minutes=10). Ensure research.canon_context is a small dict (convert from dataclass if needed). Maintain backward compatibility with activity signature from Task 9. Keep retry policy consistent with existing workflow conventions.",
            "status": "pending",
            "testStrategy": "End-to-end mocked workflow test verifying build_client_canon_activity receives a payload containing 'precanon_context' and that the value excludes bulky documents.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Persist research artifact references after canon and metric approvals",
            "description": "After existing approvals gate, invoke persist activity with research artifact refs only.",
            "dependencies": [
              3
            ],
            "details": "After canon and metric approvals (no changes to gating logic), call persist_client_onboarding_artifacts_activity with {'onboarding_payload_id': onboarding_payload_id, 'research_artifacts': [asdict(a) for a in research.artifacts]} and start_to_close_timeout=timedelta(minutes=2). Ensure only refs/summaries flow through (no full content). Propagate failures per existing retry policies to maintain consistency and idempotency.",
            "status": "pending",
            "testStrategy": "Integration-like workflow test: approvals simulated/mocked, assert persist activity is called once after approvals and that payload contains only artifact refs (no content fields).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add workflow tests: replay determinism, happy path with mocks, and child failure propagation",
            "description": "Create tests verifying sequence, payload wiring, and error handling.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "In tests/temporal/test_client_onboarding_workflow.py, use Temporal TestEnvironment to register ClientOnboardingWorkflow. Mock the child workflow to return small canon_context and artifact refs, and stub activities. Validate order: child -> canon activity -> approvals -> persist. Add replay test using recorded history to ensure determinism. Add negative test where child workflow raises, asserting failure propagates and no downstream activities run.",
            "status": "pending",
            "testStrategy": "Run pytest with Temporal test environment. Assert calls and payloads via mocks/spies. Include replay test and failure test in CI pipeline.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 11,
        "title": "Register new activities/workflow with Temporal worker and configure timeouts/concurrency",
        "description": "Wire up worker registration for new activities and workflow; set activity options and queue assignments with longer timeout for step 4.",
        "details": "In worker bootstrap (e.g., app/temporal/worker.py):\n- Import and register PreCanonMarketResearchWorkflow class.\n- Register activities: fetch_onboarding_payload_activity, get_ads_context_stub_activity, generate_research_step_artifact_activity, updated client onboarding activities.\n- Use a dedicated task queue if needed: TASK_QUEUE = 'client-onboarding'.\n- Configure worker options: max concurrent activities, heartbeats, graceful shutdown handling.\n- Ensure activity timeouts are set at call sites (already in workflows). For step 4, allow up to 15 minutes.\n- If using payload codec/compression, ensure summaries are small and compression is enabled to keep history << 2MB.\n\nPseudocode:\nworker = Worker(\n  client,\n  task_queue=TASK_QUEUE,\n  workflows=[PreCanonMarketResearchWorkflow, ClientOnboardingWorkflow],\n  activities=[fetch_onboarding_payload_activity, get_ads_context_stub_activity, generate_research_step_artifact_activity, build_client_canon_activity, persist_client_onboarding_artifacts_activity]\n)\nawait worker.run()",
        "testStrategy": "- Local worker start test: verify registration logs include new workflow and activities.\n- Smoke test: run the ClientOnboardingWorkflow end-to-end in dev against test Temporal namespace.\n- Load test: execute multiple concurrent precanon runs to validate concurrency and timeouts (especially step 4).",
        "priority": "medium",
        "dependencies": [
          "8",
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Bootstrap Temporal worker with task queue and concurrency configuration",
            "description": "Create or update the worker bootstrap to define the client-onboarding task queue and read concurrency options from environment variables.",
            "dependencies": [],
            "details": "In app/temporal/worker.py: (1) Define TASK_QUEUE = os.getenv('TASK_QUEUE', 'client-onboarding'). (2) Read env-driven settings such as WORKER_MAX_CONCURRENT_ACTIVITIES, WORKER_MAX_CONCURRENT_ACTIVITY_POLLS, WORKER_MAX_CONCURRENT_WORKFLOW_POLLS, WORKER_MAX_CACHED_WORKFLOWS, and WORKER_SHUTDOWN_SEC with sane defaults. (3) Implement async run_worker() that connects a Temporal client (namespace/target from env), then constructs Worker(client, task_queue=TASK_QUEUE, ...options...). (4) Log effective options at startup for observability.",
            "status": "pending",
            "testStrategy": "Unit test the config loader with monkeypatched env vars to ensure defaults and overrides are applied. Dry-run worker construction in a test to assert the Worker receives expected option values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Import and register new workflows and activities with the worker",
            "description": "Wire the worker to include workflows and activities required for onboarding and precanon research.",
            "dependencies": [
              1
            ],
            "details": "In app/temporal/worker.py: import PreCanonMarketResearchWorkflow and ClientOnboardingWorkflow. Import activities: fetch_onboarding_payload_activity, get_ads_context_stub_activity, generate_research_step_artifact_activity, build_client_canon_activity, persist_client_onboarding_artifacts_activity (plus any updated onboarding activities). Pass them to Worker(..., workflows=[...], activities=[...]). Keep names consistent with their modules and avoid duplicate registration. Ensure worker uses TASK_QUEUE = 'client-onboarding'.",
            "status": "pending",
            "testStrategy": "Start the worker locally and verify logs list registered workflows and activities. Confirm in Temporal Web UI that a worker is polling the client-onboarding queue. Add a small introspection test to assert the registration lists contain the expected callables.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Enable payload compression and enforce small summaries to keep history well below 2MB",
            "description": "Configure a payload codec/compression on the client/worker and ensure artifact summaries are small.",
            "dependencies": [
              1
            ],
            "details": "Add a DataConverter with a compression PayloadCodec (e.g., gzip/zlib implementation) and pass it to Client.connect(..., data_converter=dc). Ensure the same converter is used by the worker instance. Review artifact-producing activities to trim or summarize large strings before returning (e.g., cap summaries to a few KB). Add logging of payload sizes at debug level to detect risks. Document the codec env flag (e.g., ENABLE_PAYLOAD_COMPRESSION=1).",
            "status": "pending",
            "testStrategy": "Unit test a representative artifact payload to confirm compressed size is smaller than uncompressed and below a chosen threshold. In a local run, verify that client.data_converter has a payload_codec and that activity results are successfully serialized/deserialized with compression.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Audit and update activity call-site timeouts and queue assignment (step 4 up to 15 minutes)",
            "description": "Verify all activity options are set at call sites, and specifically raise step 4â€™s start-to-close timeout to 15 minutes with heartbeats.",
            "dependencies": [
              2
            ],
            "details": "Review workflow calls (e.g., in PreCanon and ClientOnboarding workflows) to ensure execute_activity includes: task_queue=TASK_QUEUE ('client-onboarding'), appropriate retry policy, heartbeat_timeout (e.g., 30s), and start_to_close_timeout. Increase step 4 activityâ€™s start_to_close_timeout to 15 minutes as required. Ensure no timeouts are set only at worker level; they must be at call sites per Temporal best practices. Update any missing heartbeats in the long-running step implementation.",
            "status": "pending",
            "testStrategy": "Create a test activity that simulates step 4 by running ~12 minutes while heartbeating. Run the workflow in dev and assert it completes within 15 minutes. Add a negative test by disabling heartbeats to observe expected timeout behavior.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement graceful shutdown handling and run smoke/load validation",
            "description": "Add clean shutdown behavior for the worker and validate registration, timeouts, and concurrency under load.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement SIGINT/SIGTERM handlers that trigger graceful worker shutdown with a bounded timeout (using WORKER_SHUTDOWN_SEC). Ensure in-flight activities are allowed to finish within the timeout when possible. Add a local script or CLI that: (1) starts the worker, (2) kicks off multiple concurrent PreCanon runs to exercise concurrency and timeouts, and (3) logs throughput and failures. Document how to run the smoke test and interpret results.",
            "status": "pending",
            "testStrategy": "Smoke: start the worker and run a single ClientOnboardingWorkflow end-to-end against a test namespace; validate expected activity/workflow execution in logs/UI. Load: launch N (e.g., 10â€“20) concurrent precanon workflows and verify no starvation and that step 4 completes with the 15-minute window. Shutdown: send SIGTERM during processing and assert a graceful drain without orphaned tasks.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 12,
        "title": "Update gating sequence in TestCampaignWorkflow to reflect research -> canon -> metric -> rest",
        "description": "Adjust test workflow gating to ensure PreCanon research completes (and approvals gate canon/metric) before downstream campaign/test steps.",
        "details": "In app/temporal/workflows/test_campaign_workflow.py (or create a new workflow if specified):\n- Insert a check or dependency that verifies the onboarding/canon prerequisites are met, i.e., research completed and approvals granted for canon/metrics (existing approval mechanisms remain unchanged).\n- If this workflow is triggered downstream, ensure it reads persisted onboarding artifacts refs if needed but does not re-run research.\n- Keep payloads minimal, only IDs/flags.\n\nPseudocode:\nif not await approvals_service.is_ready(client_id, required=['precanon_research_complete','canon_approved','metrics_approved']):\n    raise ActivityError('Prerequisites not met')\n# proceed with rest of test campaign steps",
        "testStrategy": "- Integration test: simulate end-to-end sequence where research then canon then metric completes, and verify TestCampaignWorkflow proceeds; fails otherwise.\n- Ensure no changes to approval flows beyond sequencing.\n- Replay test to maintain determinism (no I/O in workflow).",
        "priority": "low",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define gating prerequisites and activity contract for approvals readiness",
            "description": "Establish the exact gating flags and the contract the workflow will call to verify readiness before proceeding.",
            "dependencies": [],
            "details": "Document REQUIRED_APPROVAL_FLAGS = ['precanon_research_complete','canon_approved','metrics_approved'] and add a constants module or local constant in app/temporal/workflows/test_campaign_workflow.py. Specify an approvals readiness activity interface in app/temporal/activities/approvals_activities.py named 'check_approvals_ready_activity' that accepts {org_id, client_id, required_flags}. Ensure we do not alter approval mechanisms; the activity only reads state. Update worker registration plan to include this activity. Keep payloads minimal (IDs/flags only).",
            "status": "pending",
            "testStrategy": "Peer review the constants and interface; add a lightweight unit test that the REQUIRED_APPROVAL_FLAGS is exported and used by the workflow (import check).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement check_approvals_ready_activity wrapping existing approvals service",
            "description": "Create an idempotent Temporal activity to query approvals readiness without side effects.",
            "dependencies": [
              1
            ],
            "details": "In app/temporal/activities/approvals_activities.py implement @activity.defn(name='check_approvals_ready_activity') that calls approvals_service.is_ready(client_id=..., required=REQUIRED_APPROVAL_FLAGS, org_id=...). Return {'ready': bool, 'missing': [str]} rather than raising to let the workflow decide. Add logging with only IDs. Ensure no large payloads are returned. Register the activity in the worker startup. Handle transient errors with appropriate retry policy (configured in activity options).",
            "status": "pending",
            "testStrategy": "Unit tests: mock approvals_service to return true/false and exceptions; verify mapping to output dict and retries. Verify no PII or large objects are logged or returned.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Gate TestCampaignWorkflow execution with approvals readiness and minimal inputs",
            "description": "Modify the workflow to call the approvals readiness activity at start and halt if prerequisites are not met. Ensure workflow input/output remains minimal.",
            "dependencies": [
              2,
              4
            ],
            "details": "In app/temporal/workflows/test_campaign_workflow.py: (1) Add REQUIRED_APPROVAL_FLAGS constant. (2) At the beginning of run(), call check_approvals_ready_activity with {org_id, client_id, required_flags}. (3) If result.ready is False, raise workflow.ApplicationError('Prerequisites not met', details={'missing': result.missing}). (4) After gating passes, proceed with existing steps. (5) Ensure workflow input DTO only includes IDs/flags (e.g., org_id, client_id, onboarding_payload_id, needs_onboarding_artifacts: bool) and avoid passing large contexts. (6) If needs_onboarding_artifacts is True, call fetch_onboarding_artifact_refs_activity to read persisted refs, but do not re-run research. All external I/O is via activities to preserve determinism.",
            "status": "pending",
            "testStrategy": "Temporal replay test to ensure determinism (no direct I/O in workflow). Integration test with mocked activities: ready=true proceeds; ready=false raises ApplicationError and no downstream activities are invoked.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement fetch_onboarding_artifact_refs_activity to read persisted research refs only",
            "description": "Provide an activity that returns minimal onboarding artifact references (IDs/URLs) for downstream use without re-running research.",
            "dependencies": [
              1
            ],
            "details": "Create app/temporal/activities/onboarding_artifacts_activities.py with @activity.defn(name='fetch_onboarding_artifact_refs_activity'). Input: {org_id, client_id, onboarding_payload_id}. It queries storage/repo for previously persisted research artifacts (from onboarding) and returns a compact list of refs: [{'id': str, 'url': str, 'step_key': str, 'prompt_sha256': str}]. No content or large fields. Ensure idempotency and stable ordering. Register activity in worker. This activity is optional and only invoked when the workflow indicates it needs refs.",
            "status": "pending",
            "testStrategy": "Unit tests with mocked repository verifying only minimal fields are returned, repeated calls return same refs, and large content is excluded. Error path test when no artifacts exist returns empty list or well-defined error based on config.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add workflow and activity tests plus worker registration updates",
            "description": "Write tests covering positive/negative gating paths, determinism, and register new activities with the worker.",
            "dependencies": [
              3
            ],
            "details": "Add tests under tests/temporal/workflows/test_test_campaign_workflow.py: (1) Happy path: approvals ready -> workflow proceeds to a stubbed downstream step. (2) Negative: missing any of the required flags -> workflow fails fast with ApplicationError and includes missing flags. (3) Ensure needs_onboarding_artifacts=True triggers fetch activity and only consumes refs. Add unit tests for worker registration to include check_approvals_ready_activity and fetch_onboarding_artifact_refs_activity. Update any fixtures to pass only IDs/flags in payloads.",
            "status": "pending",
            "testStrategy": "Integration tests with Temporal test environment and mocked activities; replay tests for determinism; unit tests asserting worker registration and that no external I/O is called directly from workflow.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-12T21:41:11.479Z",
      "taskCount": 12,
      "completedCount": 2,
      "tags": [
        "precanon-market-research"
      ],
      "created": "2025-12-12T22:01:43.297Z",
      "description": "Tasks for precanon-market-research context"
    }
  },
  "ui-refactor": {
    "tasks": [
      {
        "id": "1",
        "title": "Install Base UI, Tailwind wiring, and portal isolation",
        "description": "Add @base-ui/react, ensure Tailwind is configured, and enable portal stacking and focus-visible styles to satisfy accessibility and popup layering requirements.",
        "details": "Implementation steps:\n- Install deps: npm i @base-ui/react @tanstack/react-query react-router-dom\n- Ensure Tailwind already configured; if not: npm i -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n- Add root isolation for portals: in index.css or globals.css: #root { isolation: isolate; }\n- Define design tokens via CSS variables (colors, spacing) and Tailwind config theme.extend to map to tokens.\n- Create src/styles/focus.css with consistent focus rings (e.g., outline and ring utilities) and include it globally.\n- Verify Base UI popups render in a portal above content.\nPseudo-code:\n/* index.css */\n@tailwind base; @tailwind components; @tailwind utilities;\n#root { isolation: isolate; }\n:root { --color-primary: 34 197 94; --color-danger: 239 68 68; }\n\n/* Example focus class */\n.focus-visible:outline-none.focus-visible:ring-2.focus-visible:ring-[rgb(var(--color-primary))];",
        "testStrategy": "- Manual: open a temporary Base UI Dialog and Menu to verify they overlay correctly (no clipping) and that focus ring is visible on Tab.\n- Automated: add a Jest/RTL test rendering a Dialog with open state and assert portal element exists and is positioned via z-index.\n- A11y: Run axe on a page with a sample dialog to ensure no focus-trap violations.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:15:29.979Z"
      },
      {
        "id": "2",
        "title": "Introduce routing with auth gating and deep links",
        "description": "Replace tab state with react-router routes and SignedIn/SignedOut gating. Implement redirect from / to /tasks and create placeholders for all pages.",
        "details": "- Add Router in src/app/routes.tsx: routes: /, /tasks, /clients, /clients/:clientId, /campaigns, /campaigns/:campaignId, /library, /workflows, /workflows/:workflowId.\n- Implement redirect: path / -> navigate to /tasks.\n- Wrap routes with Clerk gating if Clerk is already in the project: <SignedIn>AppShell</SignedIn> and <SignedOut>SignIn</SignedOut>.\n- Preserve query params and history on navigation.\nPseudo-code:\ncreateBrowserRouter([\n  { path: '/', element: <Navigate to='/tasks' replace /> },\n  { path: '/', element: <AppShell />, children: [\n    { path: 'tasks', element: <TasksPage /> },\n    { path: 'clients', element: <ClientsPage /> },\n    { path: 'clients/:clientId', element: <ClientDetailPage /> },\n    { path: 'campaigns', element: <CampaignsPage /> },\n    { path: 'campaigns/:campaignId', element: <CampaignDetailPage /> },\n    { path: 'library', element: <LibraryPage /> },\n    { path: 'workflows', element: <WorkflowsPage /> },\n    { path: 'workflows/:workflowId', element: <WorkflowDetailPage /> },\n  ]}\n]);",
        "testStrategy": "- RTL tests: navigating to / should render TasksPage after redirect; /workflows/123 should mount WorkflowDetailPage.\n- E2E (Playwright): deep link directly to /clients/:id and verify shell + page render.\n- Verify SignedOut shows sign-in layout and SignedIn shows AppShell.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.711Z"
      },
      {
        "id": "3",
        "title": "Build AppShell (Sidebar, Header, responsive Drawer)",
        "description": "Implement persistent layout with Sidebar, Header, and content outlet. Sidebar supports desktop and mobile drawer using Base UI Dialog.",
        "details": "- Create src/components/layout/Sidebar.tsx, Header.tsx, PageHeader.tsx; compose in AppShell.tsx.\n- Sidebar: links for Home/Tasks, Clients, Campaigns, Library, Workflows; show optional badge counts (pending approvals) placeholder. Use ScrollArea for overflow.\n- Mobile: hide sidebar; add a hamburger button that opens a Dialog acting as a Drawer with the same nav.\n- Header: page title area, contextual actions slot, and a User menu (Clerk <UserButton /> if present).\n- Outlet for nested routes.\nPseudo-code:\nfunction AppShell(){\n  return (\n    <div className='grid grid-cols-[240px_1fr] md:grid-cols-[240px_1fr] min-h-screen'>\n      <Sidebar />\n      <div className='flex flex-col'>\n        <Header />\n        <main className='flex-1'><Outlet /></main>\n      </div>\n      {/* Mobile */}\n      <Dialog /* as Drawer */>...</Dialog>\n    </div>\n  );\n}",
        "testStrategy": "- RTL: render AppShell and verify nav links exist and Outlet renders children.\n- Resize test: simulate small viewport and assert Drawer-trigger appears and Dialog opens/closes with focus trap.\n- Keyboard: Tab through header and nav to confirm visible focus.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.719Z"
      },
      {
        "id": "4",
        "title": "Create Base UI wrapper components (ui/*)",
        "description": "Implement thin wrappers around Base UI primitives: Button, Input+Field, Select, Dialog, AlertDialog, Menu, Tabs, Tooltip, Popover, ScrollArea, Progress to standardize API and styling.",
        "details": "- Folder: src/components/ui/\n- Ensure forwardRef and className passthrough.\n- Style via Tailwind, using Base UI data-* attributes when available for states.\n- Input wrapper integrates with Field for label/description/error slots.\n- Export only from ui layer to avoid importing from @base-ui/react elsewhere.\nPseudo-code:\n// ui/input.tsx\nexport const FormField = ({label, error, children}) => (\n  <Field>\n    <Field.Label>{label}</Field.Label>\n    {children}\n    {error && <Field.Error>{error}</Field.Error>}\n  </Field>\n);\n\n// ui/dialog.tsx\nexport const DialogRoot = Dialog; // re-export with default styles\n\n// ui/select.tsx\nexport function Select({items, value, onValueChange}){ /* map to Base UI Select */ }\n\n// ui/button.tsx\nexport const Button = forwardRef((props, ref) => <button ref={ref} {...props} className='btn base focus-visible:ring-2'/>);",
        "testStrategy": "- Unit: render each wrapper and assert ARIA roles/names exist.\n- A11y: RTL + jest-axe on Input with Field to ensure label association.\n- Snapshot for deterministic structure; verify className merge and ref forwarding.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.723Z"
      },
      {
        "id": "5",
        "title": "Add ToastProvider and global notifications API",
        "description": "Adopt Base UI Toast with a single provider and a simple useToast hook to dispatch success/error toasts from any component or mutation callback.",
        "details": "- Implement src/components/ui/toast.tsx exporting ToastProvider, ToastViewport, and useToast()/toast API.\n- Mount ToastProvider in AppShell.\n- Use role='status' or Base UI default landmark to support F6 keyboard jump to toasts.\n- Provide helpers: toast.success(msg), toast.error(msg, {description}).\nPseudo-code:\nconst ToastContext = createContext(null);\nexport function ToastProvider({children}){ /* provide context with addToast() */ }\nexport function useToast(){ return useContext(ToastContext); }\n// Example usage in mutation: onSuccess: () => toast.success('Client created')",
        "testStrategy": "- RTL: call useToast().success and assert toast appears and auto-dismisses.\n- Keyboard: ensure focus is not stolen; screen reader announces toast (aria-live polite).\n- Visual: multiple toasts stack without overlap.",
        "priority": "high",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.726Z"
      },
      {
        "id": "6",
        "title": "Create API client with error normalization",
        "description": "Centralize HTTP get/post with typed helpers, auth header, and consistent error shape {message,status,raw}.",
        "details": "- src/api/client.ts: export async function get<T>(path), post<T>(path, body), and del/patch if needed.\n- Base URL from env.\n- Include AbortController support and timeout.\n- Attach Authorization header if using Clerk (e.g., via getToken or fetch wrapper provided in the app).\n- Normalize errors to { message, status, raw } for consistent toast messaging.\nPseudo-code:\nasync function request<T>(method, path, body){\n  const res = await fetch(baseURL+path,{ method, headers: {'Content-Type':'application/json', ...(auth && {Authorization:`Bearer ${auth}`})}, body: body?JSON.stringify(body):undefined});\n  if(!res.ok){ const raw = await res.json().catch(()=>({})); throw {message: raw.message || res.statusText, status: res.status, raw}; }\n  return res.json() as Promise<T>;\n}\nexport const get = <T,>(p:string)=>request<T>('GET',p);\nexport const post = <T,>(p:string,b?:unknown)=>request<T>('POST',p,b);",
        "testStrategy": "- MSW-based tests to assert error normalization and header presence.\n- Simulate timeouts/abort to ensure cleanup without memory leaks.\n- Type tests: ensure generics infer response types in TS.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.729Z"
      },
      {
        "id": "7",
        "title": "Set up TanStack Query provider and conventions",
        "description": "Add QueryClientProvider, define query keys, and establish mutation patterns with optimistic updates and toast hooks.",
        "details": "- Create src/app/query.ts: export queryClient, QueryClientProvider wrapper.\n- Mount at app root (above AppShell).\n- Conventions: keys like ['clients'], ['client', id], ['workflows'], ['workflow', id], ['campaigns'], ['library'].\n- Define helpers: invalidate(keys...), mutation onSuccess -> invalidate + toast.success, onError -> toast.error.\nPseudo-code:\nconst queryClient = new QueryClient({ defaultOptions: { queries: { retry: 1, staleTime: 30_000 }}});\nfunction useApiMutation(opts){ return useMutation({ ...opts, onSuccess:(d,v,c)=>{opts.onSuccess?.(d,v,c); toast.success('Done');}, onError:(e)=>toast.error(e.message) }); }",
        "testStrategy": "- RTL: wrap components with provider; use a sample query and assert caching/invalidation.\n- Ensure mutations invalidate correct keys (spy on queryClient.invalidateQueries).\n- No unhandled promise rejections; errors surface via toast.",
        "priority": "high",
        "dependencies": [
          "1",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.732Z"
      },
      {
        "id": "8",
        "title": "Build Tasks/Approvals page (needs-attention queue)",
        "description": "Aggregate workflow runs requiring action into a single list with filters and deep links to workflow detail.",
        "details": "- Route: /tasks\n- Query: get('/workflows') and derive needs-attention where status in ['waiting_approval','failed'] or blocked_step present.\n- UI: filter chips (Status: Waiting Approval/Failed/Running; Kind; Client). Table/cards showing kind, client, campaign, blocked step, started at, Review button -> /workflows/:id.\n- Performance: use query select to compute derived set without recomputing in render.\nPseudo-code:\nconst {data} = useQuery(['workflows'], ()=>get('/workflows'));\nconst items = useMemo(()=>data?.filter(needsAttention),[data]);\n<Button onClick={()=>navigate(`/workflows/${row.id}`)}>Review</Button>",
        "testStrategy": "- RTL: mock /workflows with mixed statuses; verify filters and that only relevant runs show.\n- E2E: click Review navigates to detail.\n- A11y: table headers have scope, buttons have accessible names.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.735Z"
      },
      {
        "id": "9",
        "title": "Refactor Clients list with Create Client dialog and filters",
        "description": "Implement Clients list page with search, industry filter, row actions menu, and a Create Client dialog using Base UI Form/Field.",
        "details": "- Route: /clients\n- Query: useQuery(['clients'], ()=>get('/clients'))\n- UI: table with Name, Industry, Onboarding status, Markets/Languages, Actions (Menu: View, Start onboarding, Copy ID).\n- Create dialog: fields name(required), industry(optional). Validate on blur. On submit: post('/clients', body) then invalidate ['clients'] and toast.\n- Search input and industry popover filter.\nPseudo-code:\nconst createClient = useMutation((body)=>post('/clients', body), { onSuccess: ()=>qc.invalidateQueries(['clients']) });\n<Form onSubmit={handleSubmit}>\n  <FormField label='Name' required><Input name='name' required /></FormField>\n</Form>",
        "testStrategy": "- RTL: creating a client closes dialog, shows toast, and list updates.\n- Field-level validation: leaving Name empty shows inline error.\n- Row actions: clicking View navigates to /clients/:id and Start onboarding does not trigger row onClick (stopPropagation handled).",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:51:40.738Z"
      },
      {
        "id": "10",
        "title": "Client detail page with tabs and onboarding action bug fix",
        "description": "Add Client detail route with Overview/Onboarding/Campaigns/Workflows tabs and move â€œStart onboardingâ€ action here. Fix the handler signature bug.",
        "details": "- Route: /clients/:clientId\n- Query: ['client', id] for details; related lists for tabs as needed.\n- Tabs (Base UI Tabs): Overview | Onboarding | Campaigns | Workflows.\n- Move Start Onboarding here: button calls startOnboarding(clientId).\n- Fix bug: ensure handleStartOnboarding takes clientId and uses post(`/clients/${clientId}/onboarding`).\nPseudo-code:\nconst { clientId } = useParams();\nconst startOnboarding = useMutation(()=>post(`/clients/${clientId}/onboarding`, formPayload), { onSuccess: ({workflow_run_id})=> navigate(`/workflows/${workflow_run_id}`)});\n<Button onClick={()=>openWizard()}>Start onboarding</Button>",
        "testStrategy": "- RTL: verify tabs switch content; button invokes mutation with correct clientId.\n- Regression: simulate previous faulty handler signature and confirm TypeScript now enforces id param.\n- Toasts show success/error; navigation happens on success.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "6",
          "7",
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:42:54.666Z"
      },
      {
        "id": "11",
        "title": "Onboarding wizard with progressive disclosure and validation",
        "description": "Replace the giant onboarding form with a multi-step wizard (Basics â†’ Markets & Languages â†’ Offers â†’ Constraints â†’ Competitors â†’ Funnel/Goals â†’ Review) using Base UI Form/Field and Progress.",
        "details": "- Implement as full page under Client detail Onboarding tab or Dialog if required.\n- Maintain wizard state across steps; validate onBlur and on step-next; do not preemptively validate fields user hasnâ€™t touched.\n- Required: brand story/context, markets & languages, offers; others optional.\n- On submit: POST /clients/:id/onboarding; expect { workflow_run_id }; toast and navigate to /workflows/:id.\nPseudo-code:\nconst [step,setStep]=useState(1);\nfunction next(){ if(validateStep(step)){ setStep(step+1);} }\n<Form onSubmit={handleSubmit}>/* render step-specific fields via switch(step) */</Form>\nconst submit = useMutation((payload)=>post(`/clients/${id}/onboarding`, payload), { onSuccess: ({workflow_run_id})=>navigate(`/workflows/${workflow_run_id}`)});",
        "testStrategy": "- RTL: cannot advance without required fields; inline errors appear next to fields.\n- E2E: complete wizard and verify navigation to workflow detail.\n- A11y: stepper has aria-current on active step; focus moves to first invalid field when attempting next.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "10"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-12T21:53:19.430Z"
      },
      {
        "id": "12",
        "title": "Workflows list with filters and actions menu",
        "description": "Redesign Workflows list to include filters (status/kind/client/campaign), status badges, current step, and actions via Menu (Open/Stop/Copy ID).",
        "details": "- Route: /workflows\n- Query: ['workflows'] with optional client-side filters.\n- UI: table columns: Kind, Status(badge), Client, Campaign, Started, Current step, Actions.\n- Actions: Open -> navigate; Stop -> AlertDialog confirm then POST stop signal; Copy ID -> clipboard.\nPseudo-code:\nconst stop = useMutation((id)=>post(`/workflows/${id}/stop`));\n<Menu>\n  <Menu.Item onSelect={()=>navigate(`/workflows/${id}`)}>Open</Menu.Item>\n  <Menu.Item onSelect={()=>confirmStop(id)}>Stop</Menu.Item>\n  <Menu.Item onSelect={()=>navigator.clipboard.writeText(id)}>Copy ID</Menu.Item>\n</Menu>",
        "testStrategy": "- RTL: filter chips narrow table; status badge renders correct color.\n- Stop shows confirmation dialog and on confirm triggers mutation and toast.\n- Copy ID writes to clipboard (mock navigator.clipboard).",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold /workflows route, page component, and typed data fetching",
            "description": "Create the /workflows route and page shell and fetch workflows with React Query using the API client.",
            "dependencies": [],
            "details": "- Register route /workflows in the app router and link it from navigation if present.\n- Create pages/WorkflowsListPage.tsx.\n- Define Workflow type: { id, kind, status, client, campaign, startedAt, currentStep }.\n- Implement useQuery(['workflows'], ()=>get('/workflows')) with proper typing and AbortController support.\n- Render loading skeleton, error state with retry, and an empty container for table/filters.\n- Ensure consistent error handling via normalized API errors from src/api/client.",
            "status": "done",
            "testStrategy": "- MSW: mock /workflows to return list; verify spinner shows during loading then list container renders.\n- MSW error: show error alert and retry button triggers refetch.\n- Verify query key ['workflows'] used and request path correct; assert abort on unmount does not throw.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T23:36:20.684Z"
          },
          {
            "id": 2,
            "title": "Implement filters UI and URL sync (status, kind, client, campaign) with client-side filtering",
            "description": "Add filters for status, kind, client, and campaign. Sync filter state with URL search params and derive filtered data.",
            "dependencies": [
              1
            ],
            "details": "- Controls: Status (multi-select chips), Kind (multi-select chips or select), Client (combobox/select), Campaign (text input, debounced).\n- Store state in URL via useSearchParams; parse on mount to initialize.\n- Compute filteredWorkflows = useMemo(() => apply all filters to data from query, [filters, data]).\n- Add Clear filters action and show active filter chips.\n- Ensure no server roundtrips for filtering and handle case-insensitive matching for text filters.",
            "status": "done",
            "testStrategy": "- RTL: selecting status and kind chips narrows visible rows; clearing resets to full list.\n- URL reflects changes (e.g., ?status=running,waiting&kind=ingest) and restoring page from URL reapplies filters.\n- Debounced campaign filter waits before applying; test with fake timers.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T23:36:26.182Z"
          },
          {
            "id": 3,
            "title": "Build table with columns and StatusBadge component",
            "description": "Render the workflows table with columns and a badge for status plus formatted values.",
            "dependencies": [
              1,
              2
            ],
            "details": "- Use Base UI Table with columns: Kind, Status (badge), Client, Campaign, Started, Current step, Actions.\n- Create StatusBadge that maps status to color/variant (e.g., running=green, waiting=amber, failed=red, stopped=gray) with accessible labels.\n- Format Started using date-fns; handle empty/unknown values gracefully.\n- Truncate long text with title tooltips; responsive column widths.\n- Feed table rows from filteredWorkflows and render placeholder when empty.",
            "status": "done",
            "testStrategy": "- RTL: verify headers render and each row shows correct fields.\n- StatusBadge displays correct color for each status and has aria-label text.\n- Date formatting applied to Started column; long text truncates with title attribute.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T23:36:31.400Z"
          },
          {
            "id": 4,
            "title": "Add row Actions Menu: Open, Stop (confirm + POST /workflows/:id/stop), Copy ID",
            "description": "Implement per-row menu with navigation, stop confirmation and mutation, and copy-to-clipboard functionality.",
            "dependencies": [
              3
            ],
            "details": "- Add Actions menu button per row (ellipsis). Items: Open, Stop, Copy ID.\n- Open: navigate(`/workflows/${id}`); ensure menu closes and row click does not double-trigger.\n- Stop: AlertDialog confirm; useMutation((id)=>post(`/workflows/${id}/stop`)); disable confirm while pending; on success invalidate ['workflows'] and toast; on error show error toast.\n- Copy ID: navigator.clipboard.writeText(id) with fallback; show success/error toast.\n- Ensure event.stopPropagation to avoid row onClick; ensure focus is returned to the trigger after dialog close for a11y.",
            "status": "done",
            "testStrategy": "- RTL: clicking Open calls navigate with expected path.\n- Stop: opens dialog; confirming triggers post to /workflows/:id/stop; button disabled while pending; success invalidates query (assert refetch called) and shows toast; error shows error toast.\n- Copy ID: mock clipboard API; verify writeText called with id and toast shown; fallback path tested when clipboard unavailable.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T23:36:36.768Z"
          },
          {
            "id": 5,
            "title": "Integrate empty states, accessibility, and end-to-end interaction tests",
            "description": "Polish UX with empty/filtered states, a11y roles/labels, and write comprehensive integration tests for filters and actions.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "- Empty state: show friendly message when no workflows; show a distinct message with Reset filters action when filters yield zero results.\n- Accessibility: ensure Menu, Dialog, and Table have proper roles/aria; keyboard navigation for menu items and dialog buttons; focus trapping inside dialog.\n- Loading and error boundary polish; ensure toasts are announced to screen readers (aria-live).\n- Add route link in main navigation to /workflows if applicable.\n- Write integration tests covering initial render, apply/clear filters, open/stop/copy actions, and empty/error states.",
            "status": "done",
            "testStrategy": "- RTL integration: simulate user flows across filters and actions; verify DOM/a11y queries (role=table, menu, dialog) and focus order.\n- Empty/filtered states render correct messaging; Reset filters restores list.\n- Axe (or jest-axe) checks report no critical violations on the page.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T22:14:46.917Z"
          }
        ],
        "updatedAt": "2025-12-12T23:36:36.768Z"
      },
      {
        "id": "13",
        "title": "Workflow detail skeleton: header + Tabs (Summary, Steps, Artifacts, Logs)",
        "description": "Create workflow detail page with header showing status, progress, primary CTA, and tabs for Summary, Steps, Artifacts, and Logs.",
        "details": "- Route: /workflows/:workflowId\n- Query: ['workflow', id] to fetch detail (status, kind, client/campaign, blocked_step, timestamps).\n- Header: status badge, last updated, blocked step, next action CTA (Approve if waiting).\n- Tabs: Summary (high-level info), Steps (timeline), Artifacts (read-only), Logs (scrollable).\n- Use Progress to reflect overall completion percent if available.\nPseudo-code:\nconst {workflowId}=useParams();\nconst {data: wf}=useQuery(['workflow',workflowId], ()=>get(`/workflows/${workflowId}`));\n<Header cta={wf.blocked_step? <Button onClick={()=>goToSteps()}>Approve next step</Button> : null} />\n<Tabs> <Tabs.List>...</Tabs.List> <Tabs.Panel value='steps'><StepsTab wf={wf}/></Tabs.Panel> ... </Tabs>",
        "testStrategy": "- RTL: render with mocked data; verify CTA appears only when appropriate.\n- Navigation: switching tabs preserves scroll; Logs remain scrollable.\n- A11y: Tabs are keyboard-navigable and aria-controls link list/panels.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Steps tab: timeline/stepper with contextual actions",
        "description": "Display each workflow step with status and provide context-aware actions (Approve/Request changes/Retry/Stop) using Base UI primitives and toasts.",
        "details": "- Derive ordered steps (Canon, Metrics, Strategy, Experiments, Assets, Launch, Measurement, Playbook).\n- Each row: status chip (complete/waiting/failed/skipped), View artifact link, action buttons.\n- Approve -> POST /workflows/:id/signals/approve with optional payload by step.\n- Request changes -> if supported, POST /workflows/:id/signals/request-changes with a reason field (Dialog TextArea); otherwise hide.\n- Retry -> POST /workflows/:id/signals/retry\n- Stop -> AlertDialog confirm then POST /workflows/:id/stop\n- Show toast after each mutation and invalidate ['workflow', id] + ['workflows'].\nPseudo-code:\nconst approve = useMutation(({id,step,payload})=>post(`/workflows/${id}/signals/approve`, {step,...payload}), { onSuccess: ()=>qc.invalidateQueries(['workflow',id])});",
        "testStrategy": "- RTL: only valid actions enabled for the blocked step; disabled for completed steps.\n- Mutations: simulate success/error with MSW; assert toasts and cache invalidation occur.\n- A11y: AlertDialog traps focus and requires explicit confirmation for Stop.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Artifacts tab: read-only artifact viewers with JSON toggle",
        "description": "Fetch and render artifacts (canon, metric-schema, strategy, etc.) in a readable summary with a toggle to view raw JSON and optional download.",
        "details": "- Endpoints: GET /workflows/:id/artifacts/:artifactType where artifactType âˆˆ [canon, metric-schema, strategy, experiments, assets].\n- UI: list of artifact cards with summary (key fields) and a disclosure to show JSON (textarea/code block). Use ScrollArea inside the card if long.\n- Handle missing endpoints gracefully with an empty state.\nPseudo-code:\nfunction ArtifactCard({type}){\n  const {workflowId}=useParams();\n  const {data,isError}=useQuery(['artifact',workflowId,type], ()=>get(`/workflows/${workflowId}/artifacts/${type}`));\n  return isError? <Empty>Not available</Empty> : <Card><Summary data={data}/><Button onClick={()=>toggleJson()}>View JSON</Button>{show && <pre>{JSON.stringify(data,null,2)}</pre>}</Card>\n}",
        "testStrategy": "- RTL: mock JSON payloads; verify summaries render and JSON toggle works.\n- Error path: 404 shows a friendly empty state, not a crash.\n- A11y: JSON region is scrollable and accessible to screen readers (role='region' with label).",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "7",
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Logs tab: structured, scrollable logs with expandable errors",
        "description": "Render workflow logs in a scrollable panel with structured rows (step, status, timestamp, error expandable).",
        "details": "- Endpoint: GET /workflows/:id/logs (or use logs from workflow detail if included).\n- UI: virtualized or simple list depending on size; use ScrollArea to cap height; expandable error details.\n- Optionally auto-scroll to bottom on new logs when the user is at the bottom.\nPseudo-code:\nconst {data}=useQuery(['workflowLogs', id], ()=>get(`/workflows/${id}/logs`), { refetchInterval: wfRunning? 3000 : false });\n<ScrollArea className='h-[400px]'>\n  {data?.map(row => <LogRow key={row.id} {...row} />)}\n</ScrollArea>",
        "testStrategy": "- RTL: renders timestamps and statuses; expand/collapse error details.\n- Performance: ensure no reflow issues on frequent polling; turn off auto-scroll when user scrolls up.\n- A11y: Expand/collapse controls are buttons with aria-expanded state.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6",
          "7",
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Pending items approval UI (experiments/assets selection)",
        "description": "Expose selection UI for approving experiments/assets by fetching pending items and sending approved_ids payloads.",
        "details": "- Endpoints: GET /workflows/:id/pending-experiments and /pending-assets.\n- UI: checkbox list with Select All and counts; show essential metadata; default to all selected.\n- Approve action: sends POST /workflows/:id/signals/approve-experiments { approved_ids } or approve-assets accordingly.\n- If backend prefers approve-all without IDs, rename/route internally to avoid sending empty arrays.\nPseudo-code:\nconst {data: pending} = useQuery(['pending', id, type], ()=>get(`/workflows/${id}/pending-${type}`));\nconst approve = useMutation((ids)=>post(`/workflows/${id}/signals/approve-${type}`, { approved_ids: ids }));\n<Button onClick={()=>approve.mutate(selectedIds)}>Approve selected</Button>",
        "testStrategy": "- RTL: default selection includes all items; toggling updates selection; empty selection disables Approve.\n- Mutation verifies payload contains the checked IDs; on success, toast and invalidate workflow.\n- Error path: show inline error summary above the list and keep selection intact.",
        "priority": "high",
        "dependencies": [
          "6",
          "7",
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Campaigns list and detail (Overview, Planning, Workflows tabs)",
        "description": "Implement Campaigns list with client filter and detail page tabs to prepare for planning UX.",
        "details": "- Routes: /campaigns and /campaigns/:campaignId\n- List: query ['campaigns']; filter by client via Select; row click navigates to detail.\n- Detail tabs: Overview | Planning | Workflows; Planning tab hosts Business Goal form (next task).\n- TanStack Query for detail and related workflows.\nPseudo-code:\nconst {data: campaigns}=useQuery(['campaigns'], ()=>get('/campaigns'));\n<Select items={clients} onValueChange={setClientFilter}/>\n<Table rows={filteredCampaigns} onRowClick={(c)=>navigate(`/campaigns/${c.id}`)} />",
        "testStrategy": "- RTL: filter by client narrows list; navigation to detail works.\n- A11y: Select is keyboard accessible and labelled; table rows have proper roles.\n- No N+1 calls: details fetched only when route is active.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "19",
        "title": "Business Goal form and Start Planning flow",
        "description": "Create structured Business Goal form in the Campaign Planning tab using Select/NumberField and start planning, deep-linking to the workflow run.",
        "details": "- Fields: objective type (Select), numeric target (NumberField), timeframe, budget, markets, constraints.\n- Backend: either create BusinessGoal resource first or accept inline object on /campaigns/:id/plan; expect { workflow_run_id }.\n- On submit: POST /campaigns/:id/plan with the structured goal; toast success and navigate to /workflows/:workflow_run_id.\nPseudo-code:\n<Form onSubmit={onSubmit}>\n  <FormField label='Objective'><Select items={objectiveOptions} required /></FormField>\n  <FormField label='Target'><NumberField name='target' required min={0} /></FormField>\n  ...\n</Form>\nconst startPlan = useMutation((payload)=>post(`/campaigns/${id}/plan`, payload), { onSuccess: ({workflow_run_id})=>navigate(`/workflows/${workflow_run_id}`)});",
        "testStrategy": "- RTL: required fields enforced; inline errors on blur; invalid numbers blocked by native constraints.\n- E2E: successful submit navigates to workflow detail; failure shows toast and preserves inputs.\n- A11y: all inputs have labels and describedBy for help text.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "18"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "20",
        "title": "Library page (rename Swipes) with filters and detail dialog",
        "description": "Rename Swipes to Library in UI, implement grid list with filter popover (platform/format/tags), empty state, and a metadata dialog.",
        "details": "- Route: /library; label the sidebar item as Library but keep API endpoints if named /swipes.\n- Query: ['library'] via get('/swipes') or get('/library') depending on backend.\n- UI: grid cards with title and platform badges; Popover filters; Dialog for metadata display.\n- Empty state with CTA to import (placeholder action).\nPseudo-code:\nconst {data}=useQuery(['library'], ()=>get('/swipes'));\n<Popover>/* filters */</Popover>\n<Grid>{data?.map(card => <Card onClick={()=>openDialog(card)} />)}</Grid>\n<DialogRoot open={open}>/* metadata */</DialogRoot>",
        "testStrategy": "- RTL: filters narrow the grid; dialog opens/closes and traps focus.\n- Empty state displays when list empty; CTA button fires placeholder handler.\n- A11y: cards are buttons/links with accessible names; filters have labels.",
        "priority": "low",
        "dependencies": [
          "2",
          "3",
          "4",
          "6",
          "7",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Phase 2: Refresh UI wrappers with Base UI defaults, state animations, and z-index tokens",
        "description": "Revise existing ui/* wrappers to match Base UI docs-style defaults, add consistent interaction states, apply data-attribute-driven animations, and introduce shared z-index tokens. Add missing wrappers for Table, Badge, and Toast.",
        "details": "Scope\n- Update: Button, Field (and Input integration), Dialog, Tabs, Menu, Popover.\n- Add: Table, Badge, Toast wrappers in the same ui layer.\n- Goals: cohesive defaults (spacing, radius, typography), clear focus/hover/disabled states, data-* attribute animations for open/close and side transitions, shared z-index tokens applied consistently.\n\nFolders/Conventions\n- Folder: src/components/ui/\n- Continue to depend only on @base-ui/react inside this layer; app code imports from ui/* only.\n- All components support forwardRef, className merge, asChild (where relevant), and variant/size props with sensible defaults (matching Base UI docs examples where applicable).\n\nZ-index tokens\n- Add shared tokens to Tailwind and optional CSS variables for interop.\n- tailwind.config.ts (extend):\n  theme.extend.zIndex = {\n    base: '10',\n    sticky: '20',\n    dropdown: '30',\n    popover: '40',\n    toast: '50',\n    modal: '60',\n    tooltip: '70',\n    max: '9999'\n  }\n- Optionally expose tokens as CSS vars for non-Tailwind consumers:\n  :root { --z-base:10; --z-sticky:20; --z-dropdown:30; --z-popover:40; --z-toast:50; --z-modal:60; --z-tooltip:70; --z-max:9999; }\n\nAnimations and state variants\n- Install/use tailwindcss-animate or equivalent; define keyframes for fade/slide/scale and expose utility classes.\n- Use data-* selectors provided by Base UI: e.g., data-state=\"open|closed\", data-side=\"top|right|bottom|left\", data-disabled, [aria-invalid=\"true\"].\n- Example classes: data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=open]:fade-in-0 data-[state=closed]:fade-out-0 data-[side=bottom]:slide-in-from-top-2 data-[side=top]:slide-in-from-bottom-2.\n\nComponent specifics\n1) Button (ui/button.tsx)\n- API: variant: 'solid'|'outline'|'ghost' (default 'solid'); size: 'sm'|'md'|'lg' (default 'md'); leadingIcon/trailingIcon slots.\n- Defaults (docs-like): medium radius, medium padding, semibold text, visible focus ring (focus-visible:outline/offset), hover/active opacity transitions, disabled opacity + cursor-not-allowed.\n- Class recipe (example):\n  base: 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 disabled:opacity-50 disabled:cursor-not-allowed',\n  solid: 'bg-primary text-primary-foreground hover:bg-primary/90 active:bg-primary/85',\n  outline: 'border border-border bg-transparent hover:bg-accent',\n  ghost: 'hover:bg-accent',\n  sizes: sm:'h-8 px-3 text-sm', md:'h-9 px-4 text-sm', lg:'h-10 px-5 text-base'.\n\n2) Field (ui/field.tsx)\n- Compose Base UI Field parts. Provide label/description/error defaults; tight vertical rhythm; error color for [aria-invalid=true].\n- Animate error/help text with data-attribute-friendly classes (e.g., [data-hint]:animate-in).\n- Ensure Input integrates with Field: label id -> input aria-labelledby; error id -> input aria-errormessage when invalid.\n\n3) Dialog (ui/dialog.tsx)\n- Wrap Base UI Dialog primitives: Root, Trigger, Overlay, Content, Title, Description, Close.\n- Overlay defaults: fixed inset-0 bg-black/50 backdrop-blur-sm z-modal; animate with fade in/out using data-state.\n- Content defaults: rounded-lg border bg-popover p-6 shadow-xl z-modal relative; use data-side for potential origin animations; responsive max-w.\n- Ensure portal target is document.body and motion-reduce respects user preference.\n\n4) Menu (ui/menu.tsx) and Popover (ui/popover.tsx)\n- Shared surface defaults: bg-popover border rounded-md shadow-md z-popover.\n- Open/close animations: fade/scale, directional slide by data-side; focus-visible outline on items; disabled items use data-disabled.\n- Ensure proper aria roles and keyboard navigation inherited from Base UI; expose align/side/sideOffset props.\n\n5) Tabs (ui/tabs.tsx)\n- Default to underline indicator or filled active tab (configurable via variant: 'underline'|'filled').\n- Keyboard focus ring on tab; active tab styles; animated indicator using transform/transition where feasible.\n\n6) Table (ui/table.tsx) [new]\n- Provide styled wrappers: Table, Thead, Tbody, Tr, Th, Td, Caption; support density prop: 'comfortable'|'compact'.\n- Defaults: sticky header opt-in via prop; row hover; zebra striping opt-in via prop; focus-visible outline on row when row is interactive.\n- Non-virtualized; keep DOM semantic tags; forward props.\n\n7) Badge (ui/badge.tsx) [new]\n- Variants: 'default'|'secondary'|'success'|'warning'|'destructive'; size: 'sm'|'md'. Rounded-full or md per design; uppercase opt-in.\n\n8) Toast (ui/toast.tsx) [new]\n- If @base-ui/react provides Toast, wrap it; otherwise provide a thin adapter around the existing app-level toast library with standardized surface styles and z-index z-toast.\n- Viewport container position: bottom-right by default; animations: slide-in/out from bottom using data-state.\n- API: toast(message, { variant, actionLabel, onAction }); <ToastProvider><ToastViewport /></ToastProvider>.\n\nStyling/system\n- Ensure all surfaces use tokens for z-index and shadow tiers; unify radius via Tailwind theme.radius; unify spacing via Tailwind spacing scale.\n- Respect prefers-reduced-motion: use motion-safe: prefix around animate-* utilities.\n\nDocs & migration notes\n- Add *.mdx in storybook or README in src/components/ui with examples mirroring Base UI docs.\n- Call out deprecated props, if any, and the new defaults/variants.\n\nPerformance/accessibility\n- Keep DOM minimal; avoid unnecessary wrappers.\n- Ensure ARIA attributes from Base UI are preserved; verify tab order; ensure focus trap for Dialog; use aria-live for Toasts when appropriate.",
        "testStrategy": "Unit (React Testing Library + Jest)\n- Button: renders with default variant/size; className merges; disabled renders aria-disabled/disabled and hover styles are not applied; ref forwards to button element.\n- Field+Input: label is associated via htmlFor/aria-labelledby; error text is referenced by aria-errormessage when invalid; snapshots confirm structure and default classes.\n- Dialog: opening sets data-state='open' on Overlay/Content; z-index class is z-modal; pressing Escape closes; focus is trapped and returns to trigger on close.\n- Menu/Popover: trigger click toggles open; directional classes include data-[side=...] variants; items receive focus via keyboard navigation; disabled item has data-disabled and is not actionable.\n- Tabs: keyboard navigation (ArrowLeft/Right/Home/End) changes selected tab; active tab has correct styles; indicator position updates.\n- Table: semantic roles maintained; sticky header applies when prop set; density prop adjusts padding; interactive row receives focus-visible ring.\n- Badge: variant prop sets background/foreground classes; size prop sets height/padding/text size.\n- Toast: calling toast('msg') renders a toast with z-toast container; data-state transitions present for enter/exit; optional action invokes callback.\n\nA11y (jest-axe)\n- Button, Field+Input, Dialog, Menu/Popover, Tabs basic stories pass axe with no critical violations.\n\nStyle/Token verification\n- Assert components that layer on top of others use the correct z-index utilities (Overlay: z-modal, Popover/Menu: z-popover, Toast: z-toast, Tooltip if present: z-tooltip).\n- Snapshots include data-[state=*] and data-[side=*] prefixed classes for animation to guard regressions.\n\nCross-browser smoke (Playwright minimal)\n- Dialog open/close animation does not block focus on Chromium/WebKit; Popover positioning stays correct on window resize; prefers-reduced-motion disables animations.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:43:49.431Z"
      },
      {
        "id": "22",
        "title": "Phase 4: Library page card grid refresh with shared tokens and normalized typography",
        "description": "Revamp the Library (formerly Swipes) page grid to a responsive card layout that uses shared surface/border/shadow tokens, a normalized title/meta typography scale, and consistent spacing and action placement.",
        "details": "Scope\n- Apply a responsive card grid for /library that adapts from 1-up on small screens to multi-column on larger screens using CSS Grid.\n- Refactor Library cards to consume shared design tokens (surface, border, shadow, radius, spacing, typography) provided by the ui layer from Task 21.\n- Normalize title/meta typography and spacing; ensure consistent placement and behavior of primary/secondary actions.\n- Preserve and integrate with Task 20â€™s filters, data fetching, and metadata dialog.\n\nImplementation\n1) Grid structure\n- Create LibraryGrid component (src/pages/library/LibraryGrid.tsx) that renders the existing data from Task 20 using a responsive grid:\n  - Use grid-template-columns: repeat(auto-fit, minmax(var(--card-min, 260px), 1fr));\n  - Set gap: var(--space-4) (use spacing tokens).\n  - Provide container padding via var(--space-5) and respect page layout gutters.\n  - Ensure empty state rendering from Task 20 remains centered within the grid container.\n\n2) Card component\n- Create LibraryCard (src/pages/library/LibraryCard.tsx) that wraps each item. Structure:\n  - Clickable root: <button> or <a role=\"button\"> depending on navigation; preserve onClick=openDialog(card) from Task 20.\n  - Sections: optional media/thumb (top), content (title + meta), actions (bottom).\n- Styling via shared tokens from Task 21:\n  - Background: var(--surface-1), border: 1px solid var(--border-2), radius: var(--radius-md), shadow: var(--shadow-sm) with hover elevating to var(--shadow-md).\n  - Padding: var(--space-4) content; media uses aspect-ratio: 16/9 and object-fit: cover; fallback placeholder if no image.\n  - Focus: use ui/Button or focus ring tokens (outline: var(--focus-ring)) with :focus-visible.\n  - Hover/active states respect reduced motion; prefer transform/opacity with transition tokens.\n- Typography normalization:\n  - Title uses var(--type-title-sm) or a defined --font-size-md/--line-height-tight and --font-weight-medium.\n  - Meta row (platform badges, format, tags) uses --font-size-sm and subdued color var(--fg-muted).\n  - Truncation: line-clamp title to 2 lines; meta to 1 line; provide title attribute for full text.\n- Actions\n  - Primary: â€œView detailsâ€ or open dialog (existing from Task 20). Secondary: optional quick action (e.g., Copy link or Bookmark placeholder).\n  - Place actions in a bottom row with consistent spacing var(--space-3) and layout gap var(--space-2).\n  - Actions use ui/Button and ui/Badge from Task 21 for consistency.\n\n3) Tokens and themes\n- Consume tokens introduced in Task 21; if not present, map local CSS variables to Task 21 token names to avoid duplication (e.g., --surface-1, --border-2, --shadow-sm/md, --space-*, --radius-*, --focus-ring, --z-card).\n- Support dark mode by relying on theme-provided token values; do not hardcode colors.\n- Use z-index token (e.g., --z-overlay) only if stacking with Popover/Dialog is required; cards should normally sit at base stacking context.\n\n4) Accessibility\n- Card root is a single interactive element with aria-label composed from title + key meta; ensure Enter/Space activate.\n- Badges and meta have appropriate aria-hidden where decorative; ensure contrast ratios meet WCAG AA based on token colors.\n- Respect prefers-reduced-motion: reduce elevation animation/transform.\n\n5) Performance and resilience\n- Avoid heavy box-shadow on large lists; use subtle elevation tokens.\n- Ensure long titles/meta donâ€™t cause layout shift due to clamping; set min-height on content area.\n- Keep existing data fetching from Task 20; no API shape changes.\n\n6) Files to add/update\n- src/pages/library/LibraryGrid.tsx\n- src/pages/library/LibraryCard.tsx\n- src/pages/library/library-grid.css (or css-in-ts) using token variables from ui/theme (Task 21)\n- Update src/pages/library/index.tsx to replace the previous grid/card usage with the new components.\n\nExample (abridged)\n// LibraryGrid.tsx\nexport function LibraryGrid({ items, onOpen }) {\n  return (\n    <div className=\"lib-grid\" data-testid=\"library-grid\">\n      {items.map(item => (\n        <LibraryCard key={item.id} item={item} onOpen={() => onOpen(item)} />\n      ))}\n    </div>\n  );\n}\n\n// LibraryCard.tsx\nexport function LibraryCard({ item, onOpen }) {\n  return (\n    <button className=\"lib-card\" onClick={onOpen} aria-label={`${item.title} â€¢ ${item.platform}`}> \n      {item.thumb && <img className=\"lib-card__media\" src={item.thumb} alt=\"\" aria-hidden />} \n      <div className=\"lib-card__content\">\n        <h3 className=\"lib-card__title\">{item.title}</h3>\n        <div className=\"lib-card__meta\">\n          <Badge>{item.platform}</Badge>\n          {/* other meta */}\n        </div>\n      </div>\n      <div className=\"lib-card__actions\">\n        <Button size=\"sm\" onClick={onOpen}>Details</Button>\n        <Button size=\"sm\" variant=\"ghost\">Copy link</Button>\n      </div>\n    </button>\n  );\n}\n\n// library-grid.css (token usage example)\n.lib-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(var(--card-min,260px),1fr)); gap:var(--space-4); padding:var(--space-5); }\n.lib-card { background:var(--surface-1); border:1px solid var(--border-2); border-radius:var(--radius-md); box-shadow:var(--shadow-sm); padding:var(--space-4); text-align:left; transition:box-shadow var(--duration-sm) ease, transform var(--duration-sm) ease; }\n.lib-card:hover { box-shadow:var(--shadow-md); transform:translateY(-1px); }\n.lib-card:focus-visible { outline:var(--focus-ring); outline-offset:2px; }\n.lib-card__title { font:var(--type-title-sm); line-clamp:2; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }\n.lib-card__meta { margin-top:var(--space-2); color:var(--fg-muted); font-size:var(--font-size-sm); display:flex; gap:var(--space-2); align-items:center; }\n.lib-card__actions { margin-top:var(--space-4); display:flex; gap:var(--space-2); }\n",
        "testStrategy": "Unit/Component (React Testing Library + Jest)\n- Rendering: LibraryGrid renders one LibraryCard per item; each card has role=button and accessible name includes title and platform.\n- Actions: clicking Details button and pressing Enter/Space on the card both call onOpen with the correct item.\n- Truncation: long titles/meta are line-clamped (assert via computed styles/class names) and the title attribute is set with the full text.\n- Tokens present: cards render with classes that apply surface/border/shadow tokens; verify computed styles for background-color, border-color, and box-shadow are not default values.\n- Reduced motion: when prefers-reduced-motion is mocked, hover transforms are disabled (class or style change present).\n\nE2E/Responsive (Playwright)\n- Grid responsiveness: at 360px viewport, cards stack in 1 column; at 768px, grid shows at least 2 columns; at 1280px, at least 4 columns. Use locator count per row or evaluate computed grid-template-columns.\n- Focus management: tab to the first card shows visible focus ring; Enter opens metadata dialog from Task 20; dialog traps focus and closes via Escape.\n- Visual consistency: capture screenshots in light/dark mode; assert no major diffs for surface, border, shadow across themes.\n\nAccessibility\n- Run axe checks on /library with grid populated and with empty state; no violations for color contrast or interactive roles.\n- Keyboard navigation: ensure all interactive elements within the card are reachable and order is logical (card root then actions).\n\nIntegration\n- Filters from Task 20 still narrow the rendered set without layout glitches; empty state remains centered when no items.\n- Badges and Buttons are from ui/* wrappers introduced in Task 21 and render with expected variants/sizes.\n",
        "status": "pending",
        "dependencies": [
          "20",
          "21"
        ],
        "priority": "low",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-12T23:43:49.433Z",
      "taskCount": 22,
      "completedCount": 13,
      "tags": [
        "ui-refactor"
      ]
    }
  },
  "base-ui-theme": {
    "tasks": [
      {
        "id": "1",
        "title": "Audit Base UI design tokens and author docs/ThemeAudit.md",
        "description": "Inventory typography and design tokens used on base-ui.com and produce a comprehensive ThemeAudit.md. Document sans and mono font stacks, type scale, color palette and roles, border radii, shadows/elevations, and spacing scale with rationale and accessibility notes.",
        "details": "Goal\n- Create docs/ThemeAudit.md capturing the current and recommended token baseline for base-ui.com across typography, color, radii, shadows, and spacing. Include evidence (URLs, CSS sources), rationale, and accessibility considerations.\n\nScope\n- Typography: font-family stacks (sans, mono), weights, sizes, line-heights, letter-spacing, responsive scale usage.\n- Colors: raw palette (neutrals + brand), functional roles (text, background, surface, border, primary, success, warning, error, info), light/dark usage if present, contrast compliance notes.\n- Radii: scale used for corners (e.g., 0, 2, 4, 6, 8, 12, 16, 9999 for pill).\n- Shadows: elevation steps and their blur/spread/opacity (e.g., sm, md, lg, xl or 1â€“5); include focus outline as a separate token if present.\n- Spacing: scale increments and naming (e.g., 0, 2, 4, 8, 12, 16, 24, 32, 40, 48, 64).\n\nImplementation steps\n1) Collect sources\n- Audit key pages: home, components, docs, and any theme switcher/dark mode if available. Save page URLs in the doc.\n- Extract CSS variables from :root and theme scopes (e.g., [data-theme=\"dark\"]) by inspecting linked CSS files and DevTools > Elements > Computed. Copy relevant declarations verbatim into the doc under an Appendix.\n- If the site uses hard-coded values (not variables), record the computed values observed on representative elements (headings, body text, links, buttons, cards, inputs).\n\n2) Normalize into token categories\n- Map raw findings into a token proposal: use consistent naming and scales so they can be adopted later.\n- Proposed naming examples (do not change live code; document only):\n  - Typography: --font-family-sans, --font-family-mono, --font-size-{xs..4xl}, --line-height-{tight,normal,relaxed}, --font-weight-{regular,medium,semibold,bold}\n  - Color roles: --color-{role}-{state?} where role in [bg, surface, text, border, primary, success, warning, error, info]; add -fg and -bg when needed; include light/dark variants if applicable.\n  - Radii: --radius-{none,sm,md,lg,xl,full}\n  - Shadow: --shadow-{1..5}\n  - Spacing: --space-{0,1,2,3,...} on a core unit (usually 4 or 8).\n\n3) Specify recommended font stacks\n- Sans stack (example): Inter var, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji.\n- Monospace stack (example): ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, DejaVu Sans Mono, Courier New, monospace.\n- Capture current production stacks; if different, present both Current and Recommended with reasoning (availability, rendering quality, metrics compatibility).\n\n4) Define type scale\n- Identify actual sizes used for h1â€“h6, body, small, code. Note line-height and letter-spacing patterns.\n- Propose a normalized scale that covers observed usage (e.g., base 16 with steps: 12, 14, 16, 18, 20, 24, 30, 36, 48) and map to tokens: --font-size-xs:12px, --font-size-sm:14px, --font-size-md:16px, --font-size-lg:18px, --font-size-xl:20px, --font-size-2xl:24px, --font-size-3xl:30px, --font-size-4xl:36px, --font-size-5xl:48px. Provide line-height guidance (e.g., 1.4â€“1.6 for body, tighter for headings).\n\n5) Color audit and accessibility\n- Inventory base palette (brand hues and neutral gray ramp). Note representation (hex/rgb/hsl) and alpha usage.\n- Map palette to roles. For each text-on-background pairing used on the site, compute WCAG contrast ratio and annotate results (pass/fail AA and AAA where relevant) and adjustments if needed (e.g., darken primary-600 for text on white).\n- If dark mode exists, include separate role mappings and contrast notes.\n\n6) Radii, shadows, spacing\n- Record actual corner radii used across components. Propose a minimal set (e.g., 0, 2, 4, 8, 12, 16, full) and map to tokens.\n- Catalog box-shadows by elevation. Consolidate into 3â€“5 levels, preserving look while standardizing values.\n- Determine the core spacing unit (4 or 8). Derive a scale and map common component paddings/margins to token steps.\n\n7) Author docs/ThemeAudit.md\n- Structure:\n  - Title and date\n  - Summary of findings and recommendations\n  - Typography (current vs recommended): stacks, sizes, weights, line-heights\n  - Color palette and role mapping (light/dark if any) with contrast table notes\n  - Radii scale\n  - Shadows/elevations\n  - Spacing scale\n  - Appendix: Evidence (CSS snippets, screenshots references, URLs), methodology, and glossary\n- Include small code snippets showing example CSS variable declarations for the proposed tokens so future implementation is straightforward, e.g.\n  :root {\n    --font-family-sans: Inter var, Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans;\n    --font-family-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, DejaVu Sans Mono, Courier New, monospace;\n    --font-size-md: 16px;\n    --space-3: 12px;\n    --radius-md: 8px;\n    --shadow-2: 0 4px 8px rgba(0,0,0,0.08);\n    --color-text: #0B0F14;\n    --color-surface: #FFFFFF;\n    --color-primary: #2563EB;\n  }\n\nDeliverables\n- docs/ThemeAudit.md committed to the repo with the structure and content above.\n- Any supporting assets (CSV or JSON lists of extracted tokens) referenced from the doc if created during the audit.\n\nNotes\n- Do not change live site or repo styling in this task; this is documentation and recommendations only.\n- Be explicit about unknowns or assumptions and mark them for follow-up.",
        "testStrategy": "Verification checklist\n1) File presence and structure\n- Confirm docs/ThemeAudit.md exists and includes sections: Summary, Typography, Colors, Radii, Shadows, Spacing, Appendix.\n- Ensure both Current and Recommended are present for each category where differences exist.\n\n2) Typography specifics\n- Check that the doc lists both a sans and mono font stack with at least 6+ fallbacks each and includes current production stacks observed on base-ui.com.\n- Validate a coherent type scale is documented with 8â€“10 steps and associated line-height guidance.\n\n3) Colors and accessibility\n- Confirm the palette and role mapping cover text, background/surface, border, primary, success, warning, error, info.\n- Verify at least 10 representative color contrast measurements are included with WCAG AA/AAA pass/fail labeling, and any recommended adjustments are noted.\n- If dark mode exists, verify separate role mapping and contrast notes are included.\n\n4) Radii, shadows, spacing\n- Check that radii tokens cover at least 5 steps including full/pill.\n- Verify 3â€“5 shadow/elevation tokens are documented with full CSS values.\n- Confirm the spacing scale defines a base unit and at least 8 steps with example mappings to component paddings/margins.\n\n5) Evidence and traceability\n- Ensure URLs of audited pages are listed and at least 5 CSS snippets or computed-value examples are included in the Appendix.\n- Spot-check one component (e.g., Button) across states to see its tokens can be expressed using the proposed scales.\n\n6) Review\n- Peer review by a designer or frontend lead acknowledges the recommendations and no critical gaps are identified.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T22:31:37.810Z"
      },
      {
        "id": "2",
        "title": "Phase 1: Foundational styles and Tailwind token wiring",
        "description": "Create fonts.css, theme.css, and globals.css implementing Base UI docs-like tokens from ThemeAudit, wire Tailwind fonts and colors to CSS variables, import styles in the app entry, and add root isolation/body positioning for overlay correctness.",
        "details": "Overview\n- Implement foundational styles: fonts.css (font faces/stacks), theme.css (CSS variables for tokens), globals.css (Tailwind layers + global element rules).\n- Wire Tailwind theme to CSS variables for fonts and semantic colors so utility classes reflect the design tokens.\n- Import the styles in the application main entry file so they load once for the entire app.\n- Add root isolation and body positioning to ensure overlays/portals render with correct stacking and positioning.\n\nAssumptions\n- ThemeAudit.md (Task 1) defines the recommended sans/mono stacks, type scale, palette, radii, shadows, spacing, and semantic roles. Where exact values are not yet known at implementation time, leave a TODO comment with a pointer to ThemeAudit.md sections and use sensible placeholders to be replaced when Task 1 is finalized.\n- Project uses Tailwind v3+ and PostCSS pipeline with tailwindcss and autoprefixer.\n- Main entry file lives at src/main.tsx or src/index.tsx (adjust paths if different).\n\nFile structure\n- src/styles/fonts.css\n- src/styles/theme.css\n- src/styles/globals.css\n\nfonts.css\n- Define font-face blocks if hosting local fonts (e.g., Inter Variable). Use font-display: swap. If not hosting locally, skip @font-face and rely on system stack; add TODOs to switch when assets are available.\nExample:\n  @font-face {\n    font-family: \"Inter var\";\n    font-style: normal;\n    font-weight: 100 900;\n    font-display: swap;\n    src: url(\"/fonts/InterVariable.woff2\") format(\"woff2-variations\");\n  }\n- Define CSS custom properties for font stacks based on ThemeAudit:\n  :root {\n    --font-sans: \"Inter var\", ui-sans-serif, system-ui, -apple-system, \"Segoe UI\", Roboto, Helvetica, Arial, \"Apple Color Emoji\", \"Segoe UI Emoji\";\n    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  }\n- No global element rules here except variables and @font-face.\n\ntheme.css\n- Define tokens as CSS variables under :root using the recommended baseline from ThemeAudit.md. Prefer space-separated r g b for colors to enable alpha in Tailwind.\n- Provide semantic color roles and primitives used by Tailwind and the app.\nExample template (replace values per ThemeAudit):\n  :root {\n    color-scheme: light dark; /* enables correct form control theming */\n\n    /* Typography scale */\n    --font-size-xs: 12px;\n    --font-size-sm: 14px;\n    --font-size-md: 16px;\n    --font-size-lg: 18px;\n    --font-size-xl: 20px;\n    --line-height-tight: 1.2;\n    --line-height-normal: 1.5;\n    --line-height-relaxed: 1.7;\n\n    /* Radii */\n    --radius-sm: 4px;\n    --radius-md: 8px;\n    --radius-lg: 12px;\n\n    /* Spacing (sample subset) */\n    --space-1: 4px;\n    --space-2: 8px;\n    --space-3: 12px;\n    --space-4: 16px;\n\n    /* Elevations (shadow tokens as strings) */\n    --shadow-1: 0 1px 2px rgba(0,0,0,0.1), 0 1px 1px rgba(0,0,0,0.06);\n    --shadow-2: 0 2px 8px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.08);\n\n    /* Color primitives (rgb triplets) */\n    --gray-1: 255 255 255;\n    --gray-12: 17 24 28; /* darkest neutral */\n    --brand-9: 0 122 255; /* primary */\n    --success-9: 16 185 129;\n    --warning-9: 234 179 8;\n    --danger-9: 239 68 68;\n\n    /* Semantic roles */\n    --color-bg: var(--gray-1);\n    --color-surface: 248 250 252; /* subtle surface */\n    --color-fg: 17 24 39; /* text */\n    --color-muted: 100 116 139; /* secondary text */\n    --color-border: 203 213 225;\n    --color-primary: var(--brand-9);\n    --color-on-primary: 255 255 255;\n    --color-focus-ring: 59 130 246;\n  }\n- Optional dark theme hook (placeholder values until finalized):\n  [data-theme=\"dark\"] {\n    --color-bg: 17 24 28;\n    --color-surface: 24 32 38;\n    --color-fg: 240 244 247;\n    --color-muted: 165 175 185;\n    --color-border: 61 74 87;\n    /* Adjust brand ramps if needed per ThemeAudit */\n  }\n\nglobals.css\n- Compose Tailwind layers and apply global element styling using variables.\nContent:\n  @tailwind base;\n  @tailwind components;\n  @tailwind utilities;\n\n  html, body, #root { height: 100%; }\n\n  /* Root isolation for overlay correctness */\n  #root { isolation: isolate; }\n\n  /* Body positioning to anchor fixed/absolute overlays and avoid scroll bleed */\n  body {\n    position: relative;\n    min-height: 100%;\n    font-family: var(--font-sans);\n    font-size: var(--font-size-md);\n    line-height: var(--line-height-normal);\n    color: rgb(var(--color-fg));\n    background-color: rgb(var(--color-bg));\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    overflow-x: hidden;\n  }\n\n  /* Basic theming for anchors, borders using variables to ease Tailwind interop */\n  a { color: rgb(var(--color-primary)); }\n  hr { border-color: rgb(var(--color-border)); }\n\nTailwind configuration (tailwind.config.*)\n- Map Tailwind fonts and semantic colors to CSS variables with alpha support.\n- Extend ringColor and divide/border colors to use semantic tokens.\nExample snippet:\n  const colors = {\n    bg: 'rgb(var(--color-bg) / <alpha-value>)',\n    surface: 'rgb(var(--color-surface) / <alpha-value>)',\n    fg: 'rgb(var(--color-fg) / <alpha-value>)',\n    muted: 'rgb(var(--color-muted) / <alpha-value>)',\n    border: 'rgb(var(--color-border) / <alpha-value>)',\n    primary: {\n      DEFAULT: 'rgb(var(--color-primary) / <alpha-value>)',\n      fg: 'rgb(var(--color-on-primary) / <alpha-value>)',\n    },\n    success: 'rgb(var(--success-9) / <alpha-value>)',\n    warning: 'rgb(var(--warning-9) / <alpha-value>)',\n    danger: 'rgb(var(--danger-9) / <alpha-value>)',\n  };\n  module.exports = {\n    darkMode: ['class', '[data-theme=\"dark\"]'],\n    theme: {\n      extend: {\n        fontFamily: {\n          sans: ['var(--font-sans)'],\n          mono: ['var(--font-mono)'],\n        },\n        colors,\n        ringColor: {\n          DEFAULT: 'rgb(var(--color-focus-ring) / <alpha-value>)',\n        },\n        borderColor: { DEFAULT: colors.border },\n        divideColor: { DEFAULT: colors.border },\n        boxShadow: {\n          elevation1: 'var(--shadow-1)',\n          elevation2: 'var(--shadow-2)',\n        },\n        borderRadius: {\n          sm: 'var(--radius-sm)',\n          md: 'var(--radius-md)',\n          lg: 'var(--radius-lg)',\n        },\n      },\n    },\n    plugins: [],\n  };\n\nImport styles in app entry\n- In src/main.tsx or src/index.tsx, import in this order to ensure variables exist before Tailwind utilities apply:\n  import \"./styles/fonts.css\";\n  import \"./styles/theme.css\";\n  import \"./styles/globals.css\";\n\nOverlay correctness notes\n- isolation: isolate on #root ensures that overlay components using z-index stack above local content without leaking past root stacking context.\n- body { position: relative } provides a consistent containing block for absolute/fixed overlay roots; also apply overflow-x: hidden to avoid horizontal scroll from positioned layers.\n- If the app uses a dedicated portal node, create it adjacent to #root in index.html and style via position: fixed when used by overlay components (implementation of components is out of scope for Phase 1).\n\nDocumentation and TODOs\n- Add comments in theme.css linking each token group to the corresponding section in docs/ThemeAudit.md (e.g., Typography, Colors, Radii), and mark any placeholders with TODO: replace with ThemeAudit final values.\n- If using local fonts, ensure /public/fonts contains the assets and license files; otherwise document CDN path or defer to system stack.\n",
        "testStrategy": "Repository checks\n1) Files exist with content:\n   - src/styles/fonts.css defines --font-sans and --font-mono (and @font-face if applicable).\n   - src/styles/theme.css defines variables for typography, colors (rgb triplets), radii, spacing, and shadows, with semantic roles.\n   - src/styles/globals.css includes @tailwind base/components/utilities and sets body, #root rules (isolation, positioning).\n2) Main entry imports fonts.css, theme.css, globals.css in that order.\n3) tailwind.config.* maps fontFamily to CSS variables and colors to rgb(var(--...)/<alpha-value>), with ringColor/border/divide/color extensions.\n\nRuntime verification (manual or Storybook/demo page)\n4) Load app and inspect computed styles on body:\n   - font-family equals var(--font-sans) and resolves to expected stack.\n   - color equals rgb(var(--color-fg)), background-color equals rgb(var(--color-bg)).\n5) Create a test element using Tailwind utilities:\n   - class: \"bg-bg text-fg border border-border shadow-elevation1 p-4 rounded-md\" renders with the CSS variable-driven theme values.\n   - class: \"bg-primary text-primary-fg\" renders with correct brand and on-primary contrast.\n   - ring utilities (e.g., focus:ring) show the focus ring in the defined color.\n6) Toggle dark theme by setting document.documentElement.dataset.theme = 'dark' and verify bg/fg/surface/border update live without rebuild.\n7) Overlay correctness:\n   - Create a positioned child with class \"fixed inset-0 z-50 bg-black/50\" inside a portal or appended to body and verify it visually overlays page content without being obscured by other stacking contexts. Confirm #root establishes isolation and no unexpected stacking context conflicts occur.\n8) Accessibility/contrast spot-check:\n   - Use a contrast checker on primary on-primary and text on background to ensure AA or higher as per ThemeAudit recommendations.\n\nCI/lint/build checks\n9) Tailwind build succeeds with no unresolved variable references.\n10) No unused CSS layer order issues; verify utilities can reference colors without warnings.\n",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T22:31:43.248Z"
      },
      {
        "id": "3",
        "title": "Phase 2: Refresh src/ui wrappers with Base UI defaults, interaction states, data-attribute animations, and shared z-index tokens",
        "description": "Refactor and standardize UI wrapper components (Button, Field, Table, Dialog, Tabs, Badge, Toast, Menu, Popover) to use Base UI docs-like defaults, token-driven styling, data-attribute powered interactions/animations, and shared z-index tokens.",
        "details": "Scope and goals\n- Components: Button, Field (Input, Textarea, Select), Table, Dialog, Tabs, Badge, Toast, Menu, Popover.\n- Standardize defaults and API: size, variant, tone, disabled, loading/invalid states, and accessible attributes.\n- Styling must consume CSS variables/tokens from theme.css and Tailwind utilities from Phase 1.\n- Add data-attribute animations that react to data-state and data-disabled, respecting prefers-reduced-motion.\n- Use shared z-index tokens for overlays/portals to guarantee consistent stacking across components.\n\nFile structure\n- src/ui/button.tsx\n- src/ui/field/\n  - input.tsx\n  - textarea.tsx\n  - select.tsx\n- src/ui/table.tsx\n- src/ui/dialog.tsx\n- src/ui/tabs.tsx\n- src/ui/badge.tsx\n- src/ui/toast.tsx\n- src/ui/menu.tsx\n- src/ui/popover.tsx\n- src/ui/tokens.ts (JS constants referencing CSS variable tokens)\n- src/styles/ui.css (@layer components: data-attribute animations and shared component classes)\n\nShared tokens and layering\n- Ensure theme.css exposes z-index tokens (if not present, add in coordination with Phase 1 variables):\n  --z-tooltip: 10; --z-popover: 20; --z-dropdown: 30; --z-modal: 40; --z-toast: 50; --z-max: 9999.\n- In src/ui/tokens.ts:\n  export const z = { tooltip: 'var(--z-tooltip)', popover: 'var(--z-popover)', dropdown: 'var(--z-dropdown)', modal: 'var(--z-modal)', toast: 'var(--z-toast)' };\n- Use these in inline styles or style attribute for portals/overlays when needed (e.g., style={{ zIndex: `var(--z-modal)` }}).\n\nData-attribute animations (ui.css)\n- Add keyframes (fade, scale, slide) and selectors for [data-state] based transitions. Respect reduced motion.\n  @layer components {\n    @media (prefers-reduced-motion: no-preference) {\n      @keyframes ui-fade-in { from { opacity: 0 } to { opacity: 1 } }\n      @keyframes ui-fade-out { from { opacity: 1 } to { opacity: 0 } }\n      @keyframes ui-scale-in { from { opacity: 0; transform: scale(0.96) } to { opacity: 1; transform: scale(1) } }\n      @keyframes ui-slide-up-in { from { transform: translateY(4px); opacity: 0 } to { transform: translateY(0); opacity: 1 } }\n      @keyframes ui-slide-down-out { from { transform: translateY(0); opacity: 1 } to { transform: translateY(4px); opacity: 0 } }\n    }\n\n    .ui-overlay { background: color-mix(in oklab, var(--color-surface) 40%, transparent); }\n    .ui-overlay[data-state='open'] { animation: ui-fade-in 120ms ease-out both; }\n    .ui-overlay[data-state='closed'] { animation: ui-fade-out 120ms ease-in both; }\n\n    .ui-content { will-change: transform, opacity; }\n    .ui-content[data-state='open'] { animation: ui-scale-in 140ms ease-out both; }\n    .ui-content[data-state='closed'] { animation: ui-fade-out 100ms ease-in both; }\n\n    .ui-pop[data-state='open'] { animation: ui-slide-up-in 140ms ease-out both; }\n    .ui-pop[data-state='closed'] { animation: ui-slide-down-out 120ms ease-in both; }\n  }\n- Components should attach these classes to the correct nodes (e.g., Dialog overlay => .ui-overlay, content => .ui-content; Popover/Menu panel => .ui-pop).\n\nComponent implementation guidelines\n- General\n  - Use React.forwardRef with proper HTML element types.\n  - Accept className and style overrides; merge with defaults via a cn() utility.\n  - Expose standardized props: size: 'sm' | 'md' | 'lg'; variant: 'solid' | 'soft' | 'outline' | 'ghost'; tone: 'neutral' | 'primary' | 'success' | 'warning' | 'danger'.\n  - Apply disabled, aria-invalid, aria-busy, aria-expanded, aria-selected as relevant.\n  - Map interaction states using Tailwind + data attributes: hover, active, focus-visible, disabled, [data-state='open'|'closed'|'checked'].\n\n- Button (src/ui/button.tsx)\n  - Defaults: md size, neutral tone, solid variant.\n  - Styles (example class cluster): inline-flex items-center justify-center gap-2 rounded-[var(--radius-md)] px-3 py-2 font-medium\n    text-[length:var(--text-sm)] bg-[var(--color-bg-button)] text-[var(--color-fg-button)]\n    hover:bg-[var(--color-bg-button-hover)] active:bg-[var(--color-bg-button-active)]\n    focus-visible:outline focus-visible:outline-2 focus-visible:outline-[var(--color-focus)]\n    disabled:opacity-50 disabled:pointer-events-none.\n  - Provide icon slot via children or startIcon/endIcon props.\n\n- Field wrappers (input/textarea/select)\n  - Wrap native inputs, forward ref, apply consistent padding, borders, focus rings, invalid/disabled states.\n  - Add optional label, description, error message helpers, or export a FieldRoot + Label + Control pattern.\n  - States: aria-invalid, data-required, disabled. Use tokens for border and placeholder colors.\n\n- Table\n  - Provide compact and comfortable density sizes. Sticky header support (optional).\n  - Styles for thead, row hover, zebra striping via even:bg-[var(--color-surface-1)].\n\n- Dialog\n  - Wrap chosen headless primitive (e.g., existing project primitive) or implement with portal + aria:\n    - Overlay: className='ui-overlay fixed inset-0' style={{ zIndex: 'var(--z-modal)' }}\n    - Content: className='ui-content fixed inset-x-4 top-24 mx-auto w-full max-w-lg rounded-[var(--radius-lg)] bg-[var(--color-surface)] shadow-[var(--shadow-lg)]'\n  - Ensure focus trap and aria-labelledby/aria-describedby wiring.\n\n- Tabs\n  - Root/Triggers/List/Content wrappers that style [data-state='active'] triggers and provide an underline/indicator.\n  - Keyboard navigation (arrow keys) and aria-controls.\n\n- Badge\n  - Small inline component with tone + variant; rounded-full; respects contrast requirements.\n\n- Toast\n  - Container styled with style={{ zIndex: 'var(--z-toast)' }}; entry/exit animations via data-state.\n\n- Menu and Popover\n  - Panels styled with .ui-pop and zIndex of var(--z-popover) or var(--z-dropdown) as appropriate.\n  - Roving focus, keyboard dismissal (Esc), click outside to close.\n\nAccessibility and motion\n- Ensure all interactive components are reachable and operable via keyboard.\n- Provide visible focus indicators via --color-focus token.\n- Add reduced-motion fallbacks (no transform animation when prefers-reduced-motion: reduce).\n\nDocumentation and examples\n- Create a simple demo page at /__dev/ui showing each component with states, sizes, and tones.\n- Inline JSDoc on each component detailing props and usage.\n\nNotes\n- Do not hardcode color values; use CSS variables defined in theme.css. If a token is missing, add the variable to theme.css with clear naming and semantic mapping.\n- Keep components tree-shakeable and minimal; avoid adding heavy dependencies.\n",
        "testStrategy": "Repo structure and wiring\n- Verify files exist and export components as specified under src/ui/*.tsx and src/styles/ui.css is imported once (e.g., in app entry after globals.css).\n- Confirm src/ui/tokens.ts exports z token map and components reference z-index tokens via style or class utilities.\n\nToken usage\n- Inspect component code to confirm no hardcoded hex values; colors and radii reference CSS variables (theme.css) and Tailwind utilities mapped to variables.\n- Confirm shared z-index tokens are used for: Tooltip/Popover/Menu/Dialog/Toast layers.\n\nInteraction states\n- Button: verify hover, active, disabled, and focus-visible styles in the demo page. Check aria-busy/loading variant if present.\n- Fields: type into input/textarea/select; verify focus ring, invalid state (aria-invalid=true), disabled state; placeholder color uses tokens.\n- Tabs: triggers reflect [data-state='active']; arrow keys navigate; aria-controls/aria-selected are set correctly.\n\nData-attribute animations\n- Dialog: open/close emits [data-state] on overlay/content and animates using .ui-overlay and .ui-content classes.\n- Popover/Menu/Toast: panels use .ui-pop and animate on open/close; verify reduced-motion disables transforms when prefers-reduced-motion is enabled in devtools.\n\nAccessibility\n- Keyboard-only walkthrough: open Dialog (Enter/Space), navigate focus within, close via Esc and overlay click; focus returns to trigger.\n- Menu/Popover: Esc closes; tab/shift+tab cycles correctly; focus indicators visible.\n- Color contrast: spot check Button (primary/neutral), Badge, and Field focus ring contrast meets WCAG AA using built-in browser tools.\n\nZ-index layering sanity check\n- Spawn overlapping components on the demo page: open a Popover, then a Dialog, then show a Toast. Verify stacking: tooltip < popover/menu < dialog < toast.\n\nVisual regression/manual checks\n- On the demo page, verify sizes (sm/md/lg) and variants (solid/soft/outline/ghost) appear consistently across Button and Badge.\n- Table: header styling, zebra striping, hover row.\n\nAutomated tests (if test setup exists)\n- Add RTL tests for Dialog open/close focus behavior and Tabs keyboard navigation.\n- Snapshot test for Button variants and sizes to guard against class regressions.\n",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:28:33.884Z"
      },
      {
        "id": "4",
        "title": "Phase 3: App Shell and Navigation Polish aligned to Base UI docs",
        "description": "Implement a responsive app shell with a sidebar layout, top header (product identity, search, user menu), and standardized page headers with primary actions, applying surface, border, radius, and shadow tokens for a Base UI docs-like feel.",
        "details": "Scope and deliverables\n- Build a token-driven, responsive application shell that mirrors Base UI docs navigation patterns.\n- Components (TypeScript/React):\n  - src/layout/AppShell.tsx: Composes Header, Sidebar, Main; manages layout states and responsive behavior.\n  - src/layout/TopNav.tsx: Product identity/wordmark, version badge, global search trigger (Cmd/Ctrl+K), and user menu.\n  - src/layout/SidebarNav.tsx: Collapsible/resizable navigation with section groups and active-route highlighting.\n  - src/layout/PageHeader.tsx: Page title, subtitle/breadcrumbs, and primary/secondary actions area.\n  - src/layout/SearchDialog.tsx: Accessible modal search stub using Dialog from UI wrappers; wire keyboard shortcuts.\n  - src/layout/UserMenu.tsx: Account/avatar button using Menu/Popover from UI wrappers.\n  - src/styles/layout.css: Layout-specific styles consuming tokens (surfaces, borders, shadows, radii, spacing); import once after globals and ui.css.\n\nLayout and behavior\n- Structure and landmarks: <header>, <nav aria-label=\"Primary\"/role=\"navigation\">, <main>, and optional <footer>. Provide a â€œSkip to contentâ€ link that becomes visible on focus.\n- Grid/spec:\n  - Desktop md+: CSS grid with fixed header row and two columns: sidebar (minmax(240px, var(--sidebar-w, 288px))) and main (1fr). Sidebar can be collapsed to a rail (72px) or hidden.\n  - Mobile <md: Sidebar becomes an overlay drawer using Dialog semantics (focus trap, aria-modal, inert background, body scroll lock). Toggle with a button in TopNav.\n- Sidebar features:\n  - Resizer: vertical separator <div role=\"separator\" aria-orientation=\"vertical\"> with pointer drag to set --sidebar-w in px within [224, 384]. Persist in localStorage under ui.sidebar.width.\n  - Collapse: data-state=open|collapsed persisted under ui.sidebar.state. Provide keyboard toggle (Shift+S). Ensure focus remains visible when collapsing.\n  - Active item highlighting by pathname (from router) or a currentPath prop fallback. Support nested groups with disclosure controls.\n- Header features:\n  - Left: product logo/wordmark and optional version Badge (from ui/Button/Badge). Center: search trigger button; on desktop, optional inline command input can be added later. Right: user avatar button -> UserMenu (Menu/Popover), plus a theme toggle placeholder.\n  - SearchDialog: uses Dialog and respects prefers-reduced-motion; open via Cmd/Ctrl+K; close on Escape and outside click; announce via aria-describedby for shortcut hint.\n- PageHeader:\n  - Accepts title, description, breadcrumbs[], primaryAction (Button props), secondaryActions (array). Sticky optional: data-sticky attribute to add a surface with border-bottom.\n- Tokens and styling:\n  - Consume CSS variables from theme.css for surfaces (e.g., var(--surface/--surface-raised)), borders (var(--border)), radii (var(--radius-md/lg)), and shadows (var(--shadow-sm/md)).\n  - Apply data-attribute driven transitions (data-state, data-collapsed) using utilities and custom CSS; respect prefers-reduced-motion.\n  - Use z-index tokens from src/ui/tokens.ts (e.g., z.shell.header, z.shell.sidebar, z.overlay.scrim) to ensure correct stacking with other overlays.\n- Accessibility:\n  - Landmarks with aria-labels, proper button semantics, roles for menu, dialog, separator.\n  - Focus management: trap focus in mobile sidebar and search dialog; restore focus to triggering control on close.\n  - Keyboard: Tab order begins at skip link; Arrow key navigation in Sidebar groups; Space/Enter toggles; Esc closes overlays.\n  - Contrast: ensure text and borders meet WCAG AA using theme tokens.\n\nImplementation notes\n- State management: Keep layout state local to AppShell with optional controlled props for integration. Persist only primitive preferences (collapsed, width) with a small hook (usePersistentState).\n- Routing: Provide a getActiveMatch util that matches exact and prefix routes; consider case sensitivity and trailing slashes.\n- Imports: Ensure src/styles/layout.css is imported once in the app entry after globals.css and ui.css.\n- Telemetry placeholders: expose onSearchOpen/onSidebarToggle callbacks for future analytics without side effects.\n- Example usage: Export a Layout component for pages to wrap content; include PageHeader within main for each route.\n\nExample CSS snippets (abridged)\n- .app-shell { display: grid; grid-template-rows: auto 1fr; grid-template-columns: var(--sidebar-col, minmax(240px, var(--sidebar-w, 288px))) 1fr; }\n- .sidebar[data-collapsed=\"true\"] { inline-size: 72px; }\n- .page-header[data-sticky=\"true\"] { position: sticky; top: var(--header-h); background: var(--surface); box-shadow: var(--shadow-sm); border-bottom: 1px solid var(--border); z-index: var(--z-shell-header); }\n\nQuality and performance\n- Avoid layout thrash in resizer by using CSS variables and requestAnimationFrame during drag.\n- Use CSS transitions with transform/opacity; disable when prefers-reduced-motion.\n- Ensure no duplicate global style imports and no z-index magic numbers; reference tokens only.",
        "testStrategy": "Repository and structure\n1) Files exist with content and exports:\n   - src/layout/AppShell.tsx, TopNav.tsx, SidebarNav.tsx, PageHeader.tsx, SearchDialog.tsx, UserMenu.tsx\n   - src/styles/layout.css imported once in the app entry after globals.css and ui.css\n2) No console errors/warnings when rendering AppShell in development.\n\nVisual and responsive behavior\n3) View the AppShell demo route or Storybook stories at widths 320, 768, 1024, 1440:\n   - Mobile: sidebar opens as an overlay drawer covering content with a scrim; background scrolling is locked.\n   - Tablet/Desktop: persistent sidebar column; header remains fixed; content scrolls independently.\n   - PageHeader with data-sticky sticks below header and shows border/shadow tokens.\n4) Sidebar resizing: drag separator adjusts width between 224â€“384px, persists across reloads; collapsing toggles to 72px rail and back.\n\nToken application and theming\n5) Inspect computed styles:\n   - Header, Sidebar, and PageHeader backgrounds use var(--surface or --surface-raised), borders use var(--border), shadows use var(--shadow-sm/md), radii use var(--radius-*) tokens.\n   - No hardcoded hex values for surfaces/borders/shadows in layout.css.\n6) Switch light/dark (if supported) and confirm contrast remains AA for text and interactive elements in header/sidebar.\n\nAccessibility and keyboard\n7) Landmarks present: one header, one nav[aria-label=\"Primary\"], one main, and visible skip link on Tab.\n8) Keyboard interactions:\n   - Tab order: Skip link -> TopNav items -> Sidebar first item -> Main content.\n   - Cmd/Ctrl+K opens SearchDialog; Esc closes; focus returns to trigger.\n   - Sidebar overlay on mobile traps focus; Esc or clicking scrim closes; focus restores to toggle.\n   - Separator is focusable and announces as a separator; ArrowLeft/ArrowRight adjust width by 10px.\n9) Run axe or eslint-plugin-jsx-a11y with zero critical violations on layout routes/stories.\n\nNavigation state\n10) Active route highlighting updates when pathname changes; exact vs prefix matching behaves per spec (exact for leaf routes, prefix for groups).\n\nZ-index and overlays\n11) Verify stacking: Popover/Menu and Dialog from src/ui appear above header and sidebar using z-index tokens; no overlay is hidden behind header.\n\nPerformance and motion\n12) During resizer drag, no layout thrashing (<=2 style recalcs per rAF in profiler); transitions disabled when prefers-reduced-motion is on.\n\nPersistence\n13) Reload preserves sidebar width and collapsed state; clearing localStorage keys resets to defaults without errors.",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:28:49.967Z"
      },
      {
        "id": "5",
        "title": "Phase 4: Refactor Clients page to shared UI patterns and tokens",
        "description": "Refactor the Clients page to use shared Field, Table, Button, and Toast components with structured sections, accessible labels/helper text, consistent spacing, and theme tokens to align with Base UI patterns.",
        "details": "Objectives\n- Replace ad-hoc UI with standardized components from src/ui (Field, Table, Button, Toast).\n- Organize the page into clear sections (Header, Filters, Results Table) with consistent spacing using theme tokens and Tailwind utilities wired in Phase 1.\n- Ensure accessible labeling, helper/error text, and keyboard interaction patterns.\n- Provide loading, empty, error states and success/error toasts for user feedback.\n\nProposed structure\n- src/features/clients/ClientsPage.tsx: Top-level page component (route: /clients) composing header, filters, table, and toast triggers.\n- src/features/clients/ClientsFilters.tsx: Controlled form using Field components for search and status filters with labels/helper text.\n- src/features/clients/ClientsTable.tsx: Table implementation with columns and row actions using shared Table and Button.\n- src/features/clients/useClients.ts: Data hook with fetch/list/add/update/delete (mocked or wired to existing API), plus loading/error state.\n- src/features/clients/types.ts: Client type definitions.\n- src/features/clients/clients.css: Minimal page-specific layout utilities if needed; prefer Tailwind + tokens first.\n\nUI composition details\n- Header\n  - Title: â€œClientsâ€. Optional subtext describing the page purpose.\n  - Primary action Button variant=\"primary\" size=\"md\" id=\"add-client\". On click, show inline create flow or navigate to a create route; upon success, fire Toast success.\n  - If PageHeader from layout exists (Task 4), use it; otherwise, render a local header with consistent spacing and tokens.\n\n- Filters section\n  - Field.Input id=\"clients-search\" label=\"Search\" placeholder=\"Search by name or email\" helper=\"Press Enter to apply or use the button\" with clear button.\n  - Field.Select id=\"clients-status\" label=\"Status\" options: All, Active, Inactive; helper=\"Filter clients by status\".\n  - Submit Button variant=\"secondary\" size=\"sm\" and Reset Button variant=\"ghost\" size=\"sm\". Disabled states reflect form dirty/submitting.\n  - Spacing: section container uses gap-y and gap-x with token-based Tailwind classes (e.g., gap-y-[var(--space-4)], md:gap-x-[var(--space-4)]). Labels and helper text align with Field defaults from Task 3.\n\n- Results table\n  - Use Table with the following columns: Name, Email, Company, Status, Created, Actions.\n  - Sorting affordances on Name and Created (client-side sort for now). Visual indicators rely on Table defaults (data-attribute driven states).\n  - Row actions: View/Edit (primary-quiet/secondary), Delete (destructive). Confirm delete inline or via browser confirm for now; upon success, show Toast.\n  - Empty state: A single Table row spanning all columns with message and a Button to add the first client.\n  - Loading state: Skeleton rows or a loading row using aria-busy on tbody.\n  - Error state: Inline alert row with retry Button; also emit a Toast error.\n\n- Toasts\n  - Use src/ui/Toast provider/hook per Task 3. Success messages: â€œClient createdâ€, â€œClient updatedâ€, â€œClient deletedâ€. Error messages include brief reason when available.\n  - Respect prefers-reduced-motion by relying on Task 3 data-attribute animations.\n\nTheming and spacing\n- Use only token-backed Tailwind utilities and CSS variables from src/styles/theme.css for spacing, color, radii, borders, and shadows.\n- Section spacing: outer container uses padding-block and padding-inline tokens; internal sections use space-y tokens for vertical rhythm.\n- Apply radius tokens to any inline panels or cards if used.\n\nAccessibility and keyboard\n- Ensure Field components use label + helper via aria-describedby. Error text uses role=\"alert\" when present.\n- All interactive controls must be reachable by keyboard and show focus states from shared Button/Field defaults.\n- Table headers use scope=\"col\"; sortable headers have aria-sort reflecting state.\n- Toasts are announced via aria-live per shared Toast component.\n\nData and state management\n- useClients provides: clients, isLoading, error, filters, setFilters, createClient, updateClient, deleteClient, sortBy, setSortBy.\n- For this phase, you may stub with in-memory data or wire to an existing API service if present; isolate side effects within useClients to ease future integration.\n\nRouting and integration\n- Register route /clients to render ClientsPage within the existing app router. Ensure styles are loaded once via app entry (as per Task 2).\n\nNotes\n- Do not reimplement component primitives; consume src/ui/Button, src/ui/Field, src/ui/Table, and src/ui/Toast from Task 3.\n- Keep page-specific CSS minimal; prefer composition of shared components and token utilities.",
        "testStrategy": "Repository and structure\n- Verify files exist with content:\n  - src/features/clients/ClientsPage.tsx, ClientsFilters.tsx, ClientsTable.tsx, useClients.ts, types.ts\n  - Optional: src/features/clients/clients.css (if needed)\n- Confirm route /clients renders ClientsPage without console errors.\n\nVisual and spacing\n- Inspect computed styles to confirm padding, gap, and margins map to CSS variables from src/styles/theme.css (e.g., spacing values reflect token variables, not hardcoded numbers).\n- Ensure section rhythm is consistent: header, filters, and table separated by the same vertical spacing token.\n\nComponent usage and behavior\n- Fields: Each Field has a visible label and helper text; helper text is linked via aria-describedby. Invalid state shows error text and updates aria-invalid.\n- Filters: Typing in Search and selecting Status then submitting updates the table results (client-side filter acceptable). Reset clears filters.\n- Table: Column headers render with scope=\"col\"; sorting on Name and Created toggles aria-sort and updates row order. Empty/loading/error states render as specified.\n- Actions: Clicking Add Client triggers the chosen create flow; on success, a Toast appears and the table refreshes. Delete shows a confirm (native or inline) and on success shows a destructive-styled Toast.\n\nTheming and motion\n- Verify colors, radii, and shadows derive from CSS variables (no hardcoded hex/radii).\n- Toggle dark mode (if supported by tokens) and confirm legibility and contrast remain acceptable.\n- With prefers-reduced-motion: reduce animations on toasts and any transitions per shared component defaults.\n\nAccessibility\n- Run an automated a11y scan (axe or similar) on /clients: no critical issues.\n- Keyboard-only: Tab through header actions, filters, and table row actions; focus is visible and order is logical. Screen reader announces toasts via aria-live.\n\nIntegration checks\n- Confirm Toasts render in the correct stacking context and use z-index tokens from shared UI.\n- Ensure no duplicate style sheet imports; foundational styles from Task 2 are loaded once in the app entry.\n\nAcceptance criteria\n- The Clients page visually aligns with Base UI defaults, uses only shared UI primitives, passes the above interaction and accessibility checks, and contains no console errors or un-tokenized hardcoded styles.",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:29:05.322Z"
      },
      {
        "id": "6",
        "title": "Phase 4: Campaigns page refactor to shared Table, themed empty states, and consistent actions",
        "description": "Refactor the Campaigns page to use the shared Table and Button components, apply theme tokens for typography/spacing, and implement consistent loading/empty/error states with accessible interactions and bulk actions.",
        "details": "Scope and goals\n- Replace any bespoke markup with components from src/ui: Table, Button, Toast (and Field if filters are present).\n- Standardize list presentation using the shared Table for desktop and a stacked row pattern for small screens while preserving semantics and accessibility.\n- Implement themed empty/loading/error states using tokens from theme.css and consistent typography.\n- Provide primary and row-level actions (Create, Edit, Duplicate, Archive/Delete) with confirmation where appropriate and toasts for feedback.\n\nFiles and structure\n- src/features/campaigns/CampaignsPage.tsx: Page composition (header, filters, table, pagination, modals/toasts).\n- src/features/campaigns/CampaignsTable.tsx: Table with columns, sorting, selection, row actions, responsive stacked rows.\n- src/features/campaigns/CampaignRow.tsx: Presentational row for stacked/mobile view (re-uses Table styles where possible).\n- src/features/campaigns/CampaignsFilters.tsx (optional): Status/type/date filters using Field components if needed.\n- src/features/campaigns/useCampaigns.ts: Data hook for list fetching, pagination, sorting, and mutation stubs.\n- src/features/campaigns/types.ts: Campaign type, filter and sort enums, API DTOs.\n- src/features/campaigns/campaigns.css (optional): Minimal page-specific overrides that consume CSS variables/tokens only.\n\nImplementation details\n- Page header and actions\n  - Title: Campaigns. Primary action: \"Create campaign\" (Button variant=primary size=md). Secondary: bulk actions (disabled until selection).\n  - If src/layout/PageHeader.tsx exists from other work, use it; otherwise compose a simple header locally using tokens for spacing/typography.\n- Table\n  - Use src/ui/Table for markup; define columns: Name, Status, Channel, Start, End, Budget/Spend, Updated, Actions.\n  - Enable: sorting (Name, Updated), row selection (checkbox in header and rows), pagination (page size 25), sticky header.\n  - Row interactions: click on name navigates to details (do not hijack when clicking checkbox or kebab menu). Provide keyboard focus states (from ui.css) and aria-labels for action buttons.\n  - Row actions menu (Edit, Duplicate, Archive/Delete) using Button/Menu from shared UI; destructive actions confirm via Dialog (from src/ui if available).\n- States\n  - Loading: skeleton rows or loading spinner in Table body using shared tokens and data-state attributes.\n  - Empty (no data or no results): Themed panel with icon/illustration placeholder, title, supportive copy, and contextual actions: \"Create campaign\" and, when filtered, \"Clear filters\".\n  - Error: Inline error banner with retry button; show Toast on hard failures of mutations.\n- Filters (if in scope)\n  - Status select, Channel select, Date range. Use Field components and controlled state. Reflect active filters in query params.\n- Accessibility and keyboard\n  - All interactive elements must be reachable via Tab, have aria-labels, and visible focus rings using tokens.\n  - Checkbox selection announces via aria-live polite (selection count in bulk bar).\n- Theming/typography/spacing\n  - Use token-driven classes/variables for font sizes, weights, spacing, radius, borders, surfaces, and shadows. No hardcoded colors.\n- Data layer\n  - useCampaigns.ts exposes: data, isLoading, isError, page, pageSize, total, sort, setSort, selection, actions {create, edit, duplicate, archive, bulkArchive}.\n  - For now, wire to a fetcher or mock; return deterministic data for tests.\n\nRouting\n- Ensure /campaigns route renders CampaignsPage without console errors and integrates with existing AppShell if present.\n",
        "testStrategy": "Repository and structure\n- Verify files exist and export components: CampaignsPage.tsx, CampaignsTable.tsx, CampaignRow.tsx, useCampaigns.ts, types.ts, and optionally CampaignsFilters.tsx and campaigns.css.\n- Confirm /campaigns route renders CampaignsPage within the app without console errors.\n\nUI behavior checks\n- Table renders with shared Table component (inspect DOM for the componentâ€™s class/data attributes or import path usage).\n- Sorting: clicking Name and Updated headers toggles sort asc/desc and reorders rows accordingly; sort indicator updates.\n- Selection: header checkbox selects/deselects all visible rows; selection count appears; bulk actions enable/disable accordingly.\n- Row actions: each rowâ€™s action menu exposes Edit, Duplicate, Archive/Delete; destructive actions show a confirmation dialog; success/failure shows a Toast.\n- Navigation: clicking the campaign name triggers onNavigate (assert via mock) and does not trigger when clicking checkboxes or action buttons.\n\nStates and responsiveness\n- Loading: show skeleton or spinner while isLoading=true.\n- Empty (no campaigns): display themed empty state with title, body, and primary CTA \"Create campaign\"; when filters are active with zero results, show a \"Clear filters\" action.\n- Error: simulate isError=true to show inline error banner and working Retry button.\n- Responsive: at <768px, rows collapse into stacked layout using CampaignRow; ensure focus management and actions remain accessible.\n\nAccessibility\n- Run an automated a11y check (e.g., axe) on CampaignsPage: no violations at AA for color contrast and roles/labels.\n- Keyboard: Tab through header actions, filters, table headers, rows, menus, and dialogs; all operable without a mouse and visible focus states present.\n\nStyling and tokens\n- Inspect elements to confirm typography, spacing, color, and radius come from CSS variables/tokens (no hardcoded colors in Campaigns files).\n- Confirm that campaigns.css, if present, only references variables and not raw hex colors.\n",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:29:19.430Z"
      },
      {
        "id": "7",
        "title": "Phase 4: Refresh Library/Swipes card grid with tokenized surfaces, normalized typography, and responsive spacing/actions",
        "description": "Refactor the Library/Swipes card grid to use theme tokens for surface/border/shadow, apply a normalized typography scale for titles/meta, and implement responsive spacing and actions with shared UI components.",
        "details": "Scope and goals\n- Build a reusable, token-driven card grid used by Library and Swipes views.\n- Use theme tokens (surface, border, shadow, radius, spacing, typography) from theme.css and shared UI wrappers from src/ui.\n- Normalize title/meta typography, improve accessibility, and provide responsive column layout and actions.\n\nProposed structure\n- src/features/swipes/SwipesPage.tsx (compose header + grid)\n- src/features/swipes/SwipesGrid.tsx (responsive grid layout)\n- src/features/swipes/SwipeCard.tsx (card rendering + interactions)\n- src/features/swipes/useSwipes.ts (data fetching, loading/error state)\n- src/features/swipes/types.ts (Swipe type: id, title, description, tags, thumbnailUrl, updatedAt, stats, isFavorite)\n- Optional: src/features/swipes/swipes.css (scoped styles if needed)\n- If Library also consumes the grid, add a thin wrapper: src/features/library/LibraryGrid.tsx that composes SwipesGrid with its data source.\n\nImplementation details\n1) Grid layout\n- Use CSS Grid with repeat(auto-fill, minmax(240px, 1fr)) to fluidly fill available space.\n- Gaps and padding use spacing tokens (e.g., var(--space-3), var(--space-4)) via Tailwind utilities wired in Phase 1.\n- Ensure min touch target spacing around actions on small screens.\n\n2) Card surface/border/shadow (tokens)\n- Background: var(--surface-raised) or var(--surface-1) depending on theme.css naming.\n- Border: 1px solid var(--border-soft) with hover/focus-visible elevation to var(--border) for contrast.\n- Shadow: default var(--shadow-sm), on hover/focus-visible var(--shadow-md), respecting prefers-reduced-motion.\n- Radius: var(--radius-lg) for the container; inner media uses var(--radius-md).\n- Use data attributes (data-hover, data-selected, data-favorite) to drive subtle transitions.\n\n3) Typography normalization\n- Title: use the designated title size (e.g., token-mapped class for text-lg/semi-bold, tight leading). Truncate to 2 lines with line-clamp for consistency.\n- Meta: use text-sm with muted color token (e.g., var(--text-muted)) for tags, last updated, and stats.\n- Ensure consistent letter-spacing and line-height pulled from tokens.\n\n4) Actions and interactions\n- Use src/ui/Button and src/ui/Menu for primary and overflow actions (e.g., Preview, Use, Favorite, More).\n- Provide accessible labels, aria-pressed for Favorite, and tooltips via src/ui/Popover or title attribute.\n- Keyboard: Tab traversal reaches card, then actions; Enter/Space on card opens Preview, actions are fully operable by keyboard.\n- On small screens, collapse secondary actions into a single Menu button; on larger screens, show primary + secondary buttons inline.\n\n5) Media and performance\n- Thumbnail uses aspect-ratio (e.g., 16/10) and object-fit: cover; rounds corners using radius tokens.\n- Lazy-load images with loading=\"lazy\"; provide width/height attributes to minimize layout shift.\n- Use skeleton placeholders (tokenized) while loading: shimmer rows for media/title/meta.\n\n6) States\n- Loading: grid of skeleton cards (4â€“8 depending on viewport width).\n- Empty: tokenized empty state with icon, title, helper text, and primary action (e.g., Import swipes). Contrast meets AA.\n- Error: tokenized error state with retry; surface/border tokens applied; Toast for failure details.\n- Favorite toggling uses optimistic update; on failure, revert and show Toast error.\n\n7) Accessibility\n- Use a semantic list (ul/li + article) or role=\"grid\" with role=\"row\"/\"gridcell\" consistently; include aria-labels on actions.\n- Focus-visible outlines use focus tokens; ensure 3:1 contrast on focus ring against card surface.\n- Provide alt text for thumbnails; if decorative, use empty alt.\n\n8) Theming and dark mode\n- All colors derived from semantic tokens (surface/border/text/shadow). Verify dark theme contrast and shadows are appropriate.\n- Respect reduced motion for hover/press animations.\n\n9) Integration\n- Replace any legacy Library/Swipes grid or bespoke cards with the new components.\n- Ensure no duplicate global CSS; import swipes.css only in the feature if used.\n\nNotes on tokens\n- Use only variables defined in src/styles/theme.css (Phase 1). Example token names may differ; map to existing ones (surface-1/surface-raised, border-soft/border, shadow-sm/md, radius-md/lg, space-2/3/4, text-muted).\n",
        "testStrategy": "Repository and structure\n- Confirm files exist and export components without TypeScript errors:\n  - src/features/swipes/SwipesPage.tsx\n  - src/features/swipes/SwipesGrid.tsx\n  - src/features/swipes/SwipeCard.tsx\n  - src/features/swipes/useSwipes.ts\n  - src/features/swipes/types.ts\n  - Optional: src/features/swipes/swipes.css\n- If Library also uses the grid, verify a wrapper (src/features/library/LibraryGrid.tsx) exists and composes SwipesGrid.\n\nVisual and tokens\n- Inspect a rendered SwipeCard in devtools:\n  - Background uses a surface token variable.\n  - Border color uses a border token variable; radius equals radius token; box-shadow equals shadow token.\n  - Title style matches designated title size/weight; meta uses text-sm (or mapped token) and muted color token.\n  - Spacing (padding, gap) derived from spacing tokens or Tailwind utilities wired to them.\n\nResponsive behavior\n- Resize viewport at 360px, 768px, 1024px, 1440px:\n  - Grid auto-fills columns with min card width ~240px (or configured minmax) and maintains consistent gaps.\n  - On small screens, secondary actions are collapsed under an overflow menu; on larger screens, inline buttons appear.\n\nStates and interactions\n- Loading: while useSwipes is pending, skeleton cards render; no layout shift when data arrives.\n- Empty: when useSwipes returns [], an empty state renders with tokenized surface/typography and a primary action.\n- Error: simulate a fetch failure; error state renders with a Retry button and a Toast on failure.\n- Hover/focus-visible: card elevates to shadow-md and border emphasizes; focus ring is visible and meets 3:1 contrast.\n- Keyboard: Tab to a card, press Enter to open its primary action; Tab to Favorite, Space toggles aria-pressed and visual state.\n\nAccessibility\n- Run axe (or similar) on the page: no critical violations; buttons have accessible names; images have alt text.\n- Ensure focus order is logical and all interactive elements are reachable.\n\nPerformance\n- Thumbnails are lazy-loaded and include explicit width/height; CLS for the grid remains under 0.1 during load.\n\nDark mode/theming\n- Toggle dark theme (if supported by theme.css); verify surface/border/shadow tokens produce legible, balanced cards; no hard-coded colors remain.\n\nRegression\n- No console errors/warnings when navigating to and interacting with Swipes/Library pages.\n",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:29:31.875Z"
      },
      {
        "id": "8",
        "title": "Phase 4: Workflows page updatesâ€”row actions via Menu, Stop confirmation dialog, formatted logs, approvals-ready layout",
        "description": "Update the Workflows page to use shared UI components for row actions, add a Stop confirmation dialog with animated Base UI Dialog, improve logs with monospaced styling and level badges, and prepare the layout for approvals workflows.",
        "details": "Scope and goals\n- Implement row-level actions via src/ui/Menu anchored to an icon button in each workflow run row (ellipsis). Actions: View details, Stop, Duplicate (stub), Approve/Reject (conditional; stubbed if backend not ready).\n- Implement a Stop confirmation dialog using src/ui/Dialog with data-state animations, accessible focus trapping, and z-index tokens; wire to a stop handler with optimistic UI updates and toast feedback.\n- Improve logs presentation in the run details view using a monospaced font, level-aware badges (INFO/WARN/ERROR), timestamps, and copy actions; ensure scrollable container and graceful wrapping.\n- Prepare the page for approvals by adding an approvals-ready layout: surface a right-side panel/section for approvals state, show conditional Approve/Reject buttons, and badges in the table indicating awaiting_approval.\n\nProposed structure\n- src/features/workflows/WorkflowsPage.tsx: Page header, filters (optional), and table composition using shared components.\n- src/features/workflows/WorkflowsTable.tsx: Uses src/ui/Table to render runs with responsive stacked rows on small screens; includes RowActionsMenu.\n- src/features/workflows/WorkflowRow.tsx: Single row component with status/approvals badges and actions button.\n- src/features/workflows/WorkflowRunDetails.tsx: Details panel or inline expander with tabs (Overview, Logs, Approvals) using src/ui/Tabs if available; otherwise simple sections.\n- src/features/workflows/LogsPanel.tsx: Displays logs with monospaced typography, badges by level, timestamp, and copy-to-clipboard for a single line or all logs.\n- src/features/workflows/ApprovalsPanel.tsx: Approvals-ready UI with status, requested by/at, and Approve/Reject buttons (stubbed actions if API not ready).\n- src/features/workflows/StopDialog.tsx: Reusable confirmation dialog wired to a stop handler.\n- src/features/workflows/useWorkflows.ts: Data hook for fetching runs and mutating (stop, approve, reject), with mock implementations if API is pending.\n- src/features/workflows/types.ts: TypeScript types (WorkflowRun, WorkflowStatus, ApprovalStatus, LogEntry, ActionResult).\n\nImplementation details\n- Styling and tokens: consume theme tokens (surface, border, radius, shadow, spacing, typography) for row, panel, and dialog styling. Use class utilities (e.g., font-mono) or a CSS var (--font-mono) to render monospaced logs. Respect prefers-reduced-motion for dialog/menu animations via data-state selectors.\n- Row actions menu: src/ui/Menu anchored to an IconButton. Items: View details, Stop (danger tone), Duplicate, and conditional Approve/Reject when run.approvalStatus === 'awaiting_approval'. Ensure correct aria-labels and keyboard navigation (Enter/Space to open, Arrow keys to move, Escape to close).\n- Stop dialog: src/ui/Dialog with overlay and content animated via data-state=\"open|closed\". Title: \"Stop run?\"; Description with run name/id and impact note. Actions: Cancel (secondary), Stop (danger). On confirm: call stopWorkflow(runId), optimistically set status to 'stopping', then 'stopped' on success; show Toast success or error and revert on failure. Ensure focus returns to the triggering button after close.\n- Logs formatting: LogsPanel renders list items with [timestamp] [level badge] message. Badge tone mapping: INFO=neutral, WARN=warning, ERROR=critical. Provide filters (optional) and a sticky toolbar with actions: Copy visible, Copy all, Auto-scroll toggle. Ensure long lines wrap with break-words and preserve whitespace for code-like messages.\n- Approvals-ready layout: In details view, include an Approvals tab/section that renders current approval status (awaiting_approval, approved, rejected) with a badge and action buttons. If backend is not ready, wire buttons to stub handlers that update local state and show Toasts. Keep component boundaries so backend wiring is trivial later.\n- Accessibility: Menu and Dialog must be fully keyboard-accessible; add aria-controls/expanded to the actions trigger, provide role=\"dialog\" with aria-labelledby/aria-describedby, initial focus on the first button, and Escape to close. Ensure badges have discernible text and sufficient contrast.\n- Responsiveness: Table collapses to a stacked card pattern on small screens (leveraging src/ui/Table responsive patterns). Details view should be usable on small screens (either inline below the row or as a full-width section).\n- Error/empty/loading: Use shared Toast for operation results; empty state with tokens and guidance; loading spinner/skeleton; error state with retry.\n\nData and types (example)\n- WorkflowRun: { id: string; name: string; status: 'queued'|'running'|'stopping'|'stopped'|'failed'|'succeeded'; approvalStatus?: 'none'|'awaiting_approval'|'approved'|'rejected'; startedAt: string; updatedAt: string; logs: LogEntry[] }\n- LogEntry: { ts: string; level: 'INFO'|'WARN'|'ERROR'; msg: string }\n\nRouting\n- Ensure /workflows route renders WorkflowsPage within the existing app shell and uses shared UI components from src/ui.\n",
        "testStrategy": "Repository and structure\n- Verify the following files exist and export components/hooks/types without TypeScript errors:\n  - src/features/workflows/WorkflowsPage.tsx\n  - src/features/workflows/WorkflowsTable.tsx\n  - src/features/workflows/WorkflowRow.tsx\n  - src/features/workflows/WorkflowRunDetails.tsx\n  - src/features/workflows/LogsPanel.tsx\n  - src/features/workflows/ApprovalsPanel.tsx\n  - src/features/workflows/StopDialog.tsx\n  - src/features/workflows/useWorkflows.ts\n  - src/features/workflows/types.ts\n- Confirm /workflows route renders WorkflowsPage without console errors.\n\nRow actions and menu\n- In the table, each row shows an actions icon button with aria-label \"Row actions\". Clicking or pressing Enter/Space opens src/ui/Menu. Arrow keys navigate, Enter activates the item, Escape closes. Menu is correctly positioned and closes on outside click.\n\nStop confirmation dialog\n- Selecting Stop opens src/ui/Dialog with title, description, Cancel, and Stop (danger) buttons. Focus is trapped inside; initial focus on the Stop button; Escape closes. Data-state=\"open|closed\" attributes toggle, and CSS animations run unless prefers-reduced-motion is set.\n- Confirming Stop calls the stop handler, sets row status to \"stopping\" then \"stopped\" on success, and shows a success Toast. Simulate a failure path to verify error Toast and state rollback.\n- Verify overlay/content use shared z-index tokens from src/ui/tokens.ts.\n\nLogs formatting\n- Open a runâ€™s details: LogsPanel displays entries with a monospaced font, timestamp, and a level badge with correct tone mapping (INFO neutral, WARN warning, ERROR critical). Long lines wrap gracefully; container is scrollable; Auto-scroll toggle works when new mock logs stream in. Copy visible and Copy all write the expected content to the clipboard.\n\nApprovals-ready layout\n- For a run with approvalStatus='awaiting_approval', ApprovalsPanel renders status badge and Approve/Reject buttons. Clicking either updates local state and shows Toasts. For other statuses, actions are hidden and state displays correctly.\n\nResponsive and states\n- Narrow viewport to <640px: table uses stacked row pattern; actions remain accessible; details view remains usable. Verify loading, empty, and error states render with theme tokens and accessible text.\n\nAccessibility checks\n- All interactive elements have accessible names. Menu and Dialog pass basic keyboard navigation. Verify focus returns to the actions button after dialog close. Badges have sufficient contrast and readable labels.\n",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:29:43.619Z"
      },
      {
        "id": "9",
        "title": "Phase 4: QA and Accessibility pass for focus, overlays/portals (incl. iOS Safari), and responsive shell/pages",
        "description": "Perform a comprehensive QA and accessibility audit across App Shell and feature pages to validate focus rings, keyboard flows, overlay stacking/portals/backdrop behavior (including iOS Safari), and responsive layouts; document fixes and notes in README.",
        "details": "Scope and targets\n- Layout and navigation: AppShell, TopNav, SidebarNav, PageHeader, SearchDialog, UserMenu.\n- Feature pages: Clients, Campaigns, Swipes, Workflows (incl. row actions Menu, Stop confirmation Dialog, logs view), and shared UI components used therein (Button, Link, Table, Field, Menu, Dialog, Toast, Card/Grid).\n- Browsers/devices: Chrome, Firefox, Safari (macOS), iOS Safari (latest stable), Android Chrome; desktop screen readers (VoiceOver on macOS, NVDA on Windows).\n\nFocus and keyboard interaction\n- Ensure all interactive elements show a visible, consistent focus ring using tokens (e.g., focus-visible state with theme focus ring color/offset/shadow). Avoid outline: none; if suppression is required for aesthetics, replace with an equivalent or better focus indicator.\n- Verify tab order follows DOM reading order on every page; confirm no tab traps. Ensure Shift+Tab works backwards.\n- Verify Enter/Space activate buttons/links; Space toggles checkable controls. Ensure role=button on non-button elements supports keyboard activation.\n- Menus: Arrow Up/Down navigate items; Home/End jump to first/last; typeahead optional; Esc closes and returns focus to trigger. Ensure aria-haspopup, aria-expanded reflect state.\n\nDialog/overlay and portal/backdrop behavior\n- Dialog: role=dialog or alertdialog; aria-modal=true; labelledby and describedby correctly wired. Provide sensible initial focus (first focusable or specified) and return focus to opener on close.\n- Focus trap: Tab/Shift+Tab must remain within the dialog while open. Confirm no elements behind the dialog are focusable (consider inert or aria-hidden on app root when dialog open if supported by your base UI).\n- Stacking order: Validate z-index tokens establish the correct hierarchy (e.g., Tooltip/Popover/Menu < Dialog < Toast/Toaster). Verify nested overlays: a Menu opened from within a Dialog renders above the Dialog content and below any Toasts.\n- Portal root: Ensure a single portal container (e.g., #portal-root) appended to document.body and used by Dialog/Menu/Toast. Confirm no duplicate roots and correct SSR hydration if applicable.\n- Backdrop and scroll lock: Body scrolling should be locked when a modal dialog is open, including on iOS Safari; background content should not scroll or be interactable. Restore scroll position on close.\n\niOS Safari specifics\n- Dynamic viewport: Prefer height: 100dvh for full-screen backdrops/centering instead of 100vh; fallback to -webkit-fill-available. Apply safe-area padding with env(safe-area-inset-*) for overlays near screen edges.\n- Positioning: Use position: fixed for backdrops and scroll lock techniques compatible with iOS (e.g., set body position: fixed, width: 100%, top: -scrollY; restore on close).\n- Input focus within dialogs: Ensure focusing inputs in a dialog does not cause viewport jump or hidden fields; scroll into view as needed with scroll-margin and avoid forcing page scroll under the locked body.\n- Orientation changes: Validate overlay size/position and body scroll lock after rotating device.\n\nResponsive behavior for sidebar/pages\n- SidebarNav: Validate collapse/expand behavior at defined breakpoints, focus management when toggling, and ARIA states for the toggle button. Ensure it does not create horizontal scroll; contents are reachable via keyboard.\n- Page headers and grids/tables: Confirm layout reflows properly at 320, 375, 768, 1024, 1280+ px widths. For tables, verify the stacked row pattern on small screens preserves semantics (table semantics or aria roles maintained; headers remain programmatically associated). Avoid text truncation that hides important information without a tooltip/expansion.\n- Zoom and reflow: At 200% and 400% zoom on desktop, ensure no content clipping or horizontal scrolling for primary flows; verify minimum target sizes (44x44 CSS px) for interactive controls.\n\nDocumentation updates (README/notes)\n- Add an Accessibility and QA section: focus ring tokens and CSS conventions; overlay/portal architecture and z-index map; scroll-lock approach (desktop + iOS); responsive breakpoints and table stacking guidance.\n- Include a browser/device test matrix and quick commands (e.g., npm run test:a11y) if automated checks are added, and known limitations with workarounds.\n\nAcceptance criteria\n- Consistent, visible focus rings across all interactive elements without regressions in dark mode/high-contrast.\n- Dialogs and menus are accessible via keyboard and screen readers, properly stacked via portals, with correct scroll lock on desktop and iOS Safari.\n- App shell and pages remain usable and readable at mobile widths and high zoom without horizontal scroll in primary flows.\n- README/notes updated to reflect final patterns, decisions, and test matrix.\n- Zero serious/critical issues in automated a11y scans on target pages.",
        "testStrategy": "Manual QA\n1) Keyboard-only pass across: AppShell, Clients, Campaigns, Swipes, Workflows.\n   - Tab through all interactive elements; confirm visible focus, correct order, and activation via Enter/Space.\n   - Open Menus from table rows and within dialogs; verify arrow navigation, Home/End, Esc close, and focus return to trigger.\n2) Dialog tests (Stop confirmation, SearchDialog, any other modals):\n   - On open, initial focus is inside the dialog; Tab/Shift+Tab cycle within; Esc closes and returns focus to opener.\n   - Verify aria-modal, role, labelledby, and describedby in the Accessibility tree (browser dev tools).\n3) Stacking and portals:\n   - With a Dialog open, open a nested Menu and trigger a Toast. Confirm visual order: Menu above Dialog content, Toast above both, backdrop behind dialog content. Ensure no behind-the-backdrop interactions.\n   - Inspect DOM: overlays render in the portal root; there is a single portal container attached to body.\n4) Scroll lock:\n   - Open a long page, scroll midway, open a Dialog. Attempt to scroll page behind the dialogâ€”should not scroll. Close dialogâ€”original scroll position is restored.\n5) iOS Safari:\n   - iPhone (latest iOS): open Dialogs and Menus; rotate orientation; confirm backdrop size uses dynamic viewport units (no gap at top/bottom) and safe-area padding is applied. Attempt to scroll backgroundâ€”should be locked. Focus an input in a dialogâ€”field remains visible, no layout jump; closing dialog restores state.\n6) Responsive and zoom:\n   - View at widths 320, 375, 768, 1024, 1280+. Confirm Sidebar collapse/expand and that content is reachable with keyboard. No horizontal scroll in main flows.\n   - At 200% and 400% zoom on desktop, verify reflow remains functional; interactive controls meet minimum target size and maintain focus visibility.\n7) Screen reader checks:\n   - macOS VoiceOver and Windows NVDA: Open/close Dialogs; ensure titles are announced, description read, and focus lands appropriately. Use landmarks to navigate AppShell; ensure skip-link works if present.\n8) Color/contrast:\n   - Verify focus ring, text, and icon contrast meet WCAG 2.1 AA. Check dark mode if supported.\n9) Automated checks:\n   - Run axe or Lighthouse a11y on each target page; resolve all serious/critical violations.\n   - If available, run Playwright/Cypress tests that assert focus trap, focus return, and ESC behavior for Dialog and keyboard navigation for Menu.\n10) Documentation:\n   - Confirm README/notes updated with a11y patterns, z-index map, portal root id, scroll-lock approach, responsive breakpoints, and test matrix.\n\nPass criteria: All acceptance criteria met and zero serious/critical automated a11y violations; issues found are fixed or tracked with linked follow-up tickets.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "6",
          "7",
          "8"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-12T23:30:04.672Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-12T23:30:04.674Z",
      "taskCount": 9,
      "completedCount": 9,
      "tags": [
        "base-ui-theme"
      ]
    }
  }
}